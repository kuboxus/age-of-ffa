<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Age of War: FFA Multiplayer</title>
    
    <!-- Firebase Imports -->
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #222; color: white; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; touch-action: none; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #333; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #777; }

        .game-ui { position: absolute; pointer-events: none; width: 100%; height: 100%; top: 0; left: 0; }
        .pointer-events-auto { pointer-events: auto; }
        
        .unit-card { transition: all 0.05s; background: rgba(0,0,0,0.8); border: 2px solid #444; }
        .unit-card:hover { border-color: #fff; transform: translateY(-2px); }
        .unit-card:active { transform: translateY(0); border-color: #eab308; }
        .unit-card.disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }

        .btn-primary { background: #eab308; color: #000; font-weight: bold; padding: 8px 16px; border-radius: 4px; transition: 0.2s; }
        .btn-primary:hover { background: #facc15; }
        .btn-danger { background: #ef4444; color: #fff; font-weight: bold; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
        .btn-danger:hover { background: #dc2626; }
        
        .tooltip { display: none; position: absolute; background: rgba(0,0,0,0.9); border: 1px solid #666; padding: 12px; border-radius: 6px; font-size: 14px; z-index: 100; pointer-events: none; width: 260px; text-align: left; }
        .unit-card:hover .tooltip { display: block; bottom: 110%; left: 50%; transform: translateX(-50%); }

        #lobby-screen { background: url('data:image/svg+xml;utf8,<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g fill="%23333"><path d="M0 0h50v50H0zM50 50h50v50H50z"/></g></svg>'); }
        
        .glass-panel { background: rgba(20, 20, 20, 0.85); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 4px 30px rgba(0,0,0,0.5); }
        
        /* Queue items scaled up */
        .queue-item { width: 45px; height: 45px; border: 1px solid #666; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; font-size: 24px; position: relative; }
        .queue-progress { position: absolute; bottom: 0; left: 0; height: 3px; background: #0f0; transition: width 0.1s linear; }
        
        input[type="color"] { -webkit-appearance: none; border: none; width: 40px; height: 40px; cursor: pointer; background: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid #666; border-radius: 8px; }

        .lobby-list-item { cursor: pointer; transition: background 0.2s; }
        .lobby-list-item:hover { background: rgba(255,255,255,0.1); }
        
        /* Range Slider Styling */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #eab308; cursor: pointer; margin-top: -6px; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #555; border-radius: 2px; }
    </style>
</head>
<body>

<!-- === INITIALIZATION & DATA === -->
<script>
    // --- Configuration ---
    const VERSION = "v3.0";
    
    // Default Settings
    const DEFAULT_SETTINGS = {
        mode: 'FFA', // 'FFA' or 'TEAMS'
        gameSpeed: 1.0,
        unitCostMult: 1.0,
        goldMult: 1.0,
        xpMult: 1.0,
        baseHp: 2500,
        xpToLevelMult: 1.0,
        teamPositioning: 'together', // 'together' or 'checkerboard'
        teams: [
            { name: "Team 1", color: "#3b82f6" }, // Blue
            { name: "Team 2", color: "#ef4444" }  // Red
        ]
    };

    const GAME_DATA = {
        ages: [
            {
                name: "Stone Age",
                xpReq: 0,
                special: { name: "Meteor Strike", damage: 200, radius: 100, cooldown: 60 },
                units: [
                    { id: 'u1_1', name: "Club Man", icon: "ü™®", cost: 15, delay: 1.0, hp: 55, meleeDmg: 16, rangedDmg: 0, meleeRange: 20, rangedRange: 0 },
                    { id: 'u1_2', name: "Slingshot Man", icon: "üß∂", cost: 25, delay: 1.0, hp: 42, meleeDmg: 10, rangedDmg: 8, meleeRange: 20, rangedRange: 100 },
                    { id: 'u1_3', name: "Dino Rider", icon: "ü¶ñ", cost: 100, delay: 3.0, hp: 160, meleeDmg: 40, rangedDmg: 0, meleeRange: 45, rangedRange: 0 }
                ],
                turret: { id: 't1', name: "Rock Catapult", icon: "ü™µ", cost: 100, damage: 25, range: 200, cooldown: 80 }
            },
            {
                name: "Medieval Age",
                xpReq: 1000,
                special: { name: "Arrow Rain", damage: 400, radius: 120, cooldown: 70 },
                units: [
                    { id: 'u2_1', name: "Sword Man", icon: "‚öîÔ∏è", cost: 50, delay: 2.0, hp: 100, meleeDmg: 32, rangedDmg: 0, meleeRange: 20, rangedRange: 0 },
                    { id: 'u2_2', name: "Archer", icon: "üèπ", cost: 75, delay: 1.0, hp: 80, meleeDmg: 20, rangedDmg: 9, meleeRange: 20, rangedRange: 130 },
                    { id: 'u2_3', name: "Knight", icon: "üê¥", cost: 500, delay: 3.0, hp: 300, meleeDmg: 60, rangedDmg: 0, meleeRange: 60, rangedRange: 0 }
                ],
                turret: { id: 't2', name: "Ballista", icon: "üèπ", cost: 400, damage: 50, range: 250, cooldown: 70 }
            },
            {
                name: "Renaissance",
                xpReq: 4000,
                special: { name: "Artillery Strike", damage: 800, radius: 150, cooldown: 80 },
                units: [
                    { id: 'u3_1', name: "Duelist", icon: "üó°Ô∏è", cost: 200, delay: 3.0, hp: 200, meleeDmg: 79, rangedDmg: 0, meleeRange: 25, rangedRange: 0 },
                    { id: 'u3_2', name: "Musketeer", icon: "üî´", cost: 400, delay: 3.0, hp: 160, meleeDmg: 40, rangedDmg: 20, meleeRange: 25, rangedRange: 130 },
                    { id: 'u3_3', name: "Cannoneer", icon: "üí£", cost: 1000, delay: 5.0, hp: 600, meleeDmg: 120, rangedDmg: 0, meleeRange: 25, rangedRange: 0 }
                ],
                turret: { id: 't3', name: "Cannon Turret", icon: "üí£", cost: 1000, damage: 120, range: 300, cooldown: 120 }
            },
            {
                name: "Modern Age",
                xpReq: 16000,
                special: { name: "Airstrike", damage: 1500, radius: 180, cooldown: 90 },
                units: [
                    { id: 'u4_1', name: "Melee Infantry", icon: "üéñÔ∏è", cost: 1500, delay: 3.0, hp: 300, meleeDmg: 100, rangedDmg: 0, meleeRange: 25, rangedRange: 0 },
                    { id: 'u4_2', name: "Machine Gunner", icon: "üî´", cost: 2000, delay: 3.0, hp: 350, meleeDmg: 60, rangedDmg: 30, meleeRange: 25, rangedRange: 130 }, 
                    { id: 'u4_3', name: "Tank", icon: "üöú", cost: 7000, delay: 8.0, hp: 1200, meleeDmg: 300, rangedDmg: 0, meleeRange: 100, rangedRange: 0 }
                ],
                turret: { id: 't4', name: "Machine Gun", icon: "üî´", cost: 4000, damage: 50, range: 350, cooldown: 10 }
            },
            {
                name: "Future Age",
                xpReq: 60000,
                special: { name: "Ion Cannon", damage: 6000, radius: 250, cooldown: 120 },
                units: [
                    { id: 'u5_1', name: "Alien Blade", icon: "üëΩ", cost: 5000, delay: 3.0, hp: 1000, meleeDmg: 250, rangedDmg: 0, meleeRange: 40, rangedRange: 0 },
                    { id: 'u5_2', name: "Alien Blaster", icon: "‚ö°", cost: 6000, delay: 3.0, hp: 800, meleeDmg: 130, rangedDmg: 80, meleeRange: 40, rangedRange: 130 },
                    { id: 'u5_3', name: "War Machine", icon: "üëπ", cost: 20000, delay: 8.0, hp: 3000, meleeDmg: 600, rangedDmg: 0, meleeRange: 100, rangedRange: 0 },
                    { id: 'u5_4', name: "Super Soldier", icon: "ü¶∏", cost: 150000, delay: 3.0, hp: 4000, meleeDmg: 400, rangedDmg: 400, meleeRange: 40, rangedRange: 150 }
                ],
                turret: { id: 't5', name: "Laser Battery", icon: "‚ö°", cost: 15000, damage: 800, range: 450, cooldown: 60 }
            }
        ],
        turretSlots: 2,
        mapRadius: 1000,
        baseRadius: 90, 
        unitCollisionRadius: 20 
    };
    
    // Globals
    let db, auth, user;
    let appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';
    let lobbyId = null;
    let isHost = false;
    let localPlayerId = null;
    let gameLoopRef = null;
    let gameState = null;
    let canvas, ctx;
    let camera = { x: 0, y: 0, zoom: 0.8 };
    let input = { keys: {}, mouse: { x: 0, y: 0, down: false }, targetId: null, mode: 'select' }; 
    let lastUnitBuyTime = 0; 
    let lastUpdateReceived = Date.now(); 
    let activeSettings = { ...DEFAULT_SETTINGS }; // Local copy of active game settings

    // --- NETWORKING & PREDICTION STATE ---
    let renderState = {
        units: new Map(), // Map<unitId, {x, y, ...targetProps}>
        projectiles: [] // Local sim
    };
    
    let pendingQueue = []; 
    let lobbyUnsub = null;
    let updateSettingsDebounce = null;
    
    const getLobbyRef = () => db.collection('artifacts').doc(appId).collection('public').doc('data').collection('lobbies');

    async function initApp() {
        // Random Name Gen
        const names = ["Warlord", "Strategist", "Commander", "General", "Captain", "Tactician", "Emperor", "King"];
        const randomName = names[Math.floor(Math.random() * names.length)] + " " + Math.floor(Math.random() * 1000);
        const nameInput = document.getElementById('lobby-name');
        if(nameInput) nameInput.value = randomName;
        
        // Random Color Gen
        const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
        const colorInput = document.getElementById('player-color');
        if(colorInput) colorInput.value = randomColor;

        const firebaseConfig = {
			apiKey: "AIzaSyAhVZB64ov5te0w5he0zeCNuOZuy7jUpuI",
			authDomain: "ageofffa.firebaseapp.com",
			projectId: "ageofffa",
			storageBucket: "ageofffa.firebasestorage.app",
			messagingSenderId: "461491837298",
			appId: "1:461491837298:web:daebae2fb46fe3eb3ee5eb"
		};
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        db = firebase.firestore();
        auth = firebase.auth();

        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            await auth.signInWithCustomToken(__initial_auth_token);
        } else {
            await auth.signInAnonymously();
        }

        auth.onAuthStateChanged(u => {
            user = u;
            if (user) {
                localPlayerId = user.uid;
                document.getElementById('auth-status').innerText = `Connected (${VERSION})`;
                document.getElementById('auth-status').classList.add('text-green-500');
                document.getElementById('version-display').innerText = VERSION;
                showScreen('lobby-screen');
                startLobbyBrowser();
            }
        });
    }
    
    function startLobbyBrowser() {
        getLobbyRef().onSnapshot(snapshot => {
            const listEl = document.getElementById('active-lobbies-list');
            if(!listEl) return;
            
            listEl.innerHTML = '';
            
            const activeLobbies = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                if (data.status === 'waiting' && !data.isPrivate) {
                    activeLobbies.push({ id: doc.id, ...data });
                }
            });
            
            if (activeLobbies.length === 0) {
                listEl.innerHTML = '<div class="text-gray-500 text-sm text-center">No active public games found.</div>';
                return;
            }

            activeLobbies.forEach(lobby => {
                const el = document.createElement('div');
                el.className = 'lobby-list-item bg-gray-800 border border-gray-600 p-2 rounded mb-2 flex justify-between items-center';
                el.innerHTML = `
                    <div>
                        <div class="font-bold text-yellow-500">${lobby.name}</div>
                        <div class="text-xs text-gray-400">Players: ${lobby.players.length}</div>
                        <div class="text-xs text-blue-300">${lobby.settings?.mode || 'FFA'}</div>
                    </div>
                    <button class="bg-blue-600 text-xs px-2 py-1 rounded">Join</button>
                `;
                el.onclick = () => {
                    document.getElementById('lobby-id-input').value = lobby.id;
                    joinLobby();
                };
                listEl.appendChild(el);
            });
        });
    }

    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    }

    // --- Lobby Logic ---
    async function createLobby() {
        const lobbyNameVal = document.getElementById('lobby-name').value || "New Game";
        const playerNameVal = document.getElementById('lobby-name').value || "Player 1";
        const colorVal = document.getElementById('player-color').value || "#ff0000";
        const isPrivate = document.getElementById('is-private-lobby').checked;
        
        const shortCode = Math.random().toString(36).substring(2, 8).toUpperCase();
        const lobbyRef = getLobbyRef().doc(shortCode);
        lobbyId = shortCode;
        
        const initialPlayer = createPlayerObj(localPlayerId, playerNameVal, false, colorVal);
        
        await lobbyRef.set({
            hostId: localPlayerId,
            name: lobbyNameVal,
            status: 'waiting',
            isPrivate: isPrivate,
            players: [initialPlayer],
            settings: DEFAULT_SETTINGS,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            lastHeartbeat: firebase.firestore.FieldValue.serverTimestamp(),
            stateJSON: JSON.stringify({ units: [], projectiles: [], effects: [] }),
            actions: []
        });

        enterLobbyUI(lobbyId, true);
    }

    async function joinLobby() {
        let id = document.getElementById('lobby-id-input').value.trim();
        const playerNameVal = document.getElementById('lobby-name').value || "Player";
        const colorVal = document.getElementById('player-color').value || "#00ff00";

        if(!id) return alert("Enter Lobby ID");
        if (id.length <= 8) id = id.toUpperCase();
        
        const lobbyRef = getLobbyRef().doc(id);
        const doc = await lobbyRef.get();
        
        if(!doc.exists) return alert("Lobby not found");
        if(doc.data().status !== 'waiting') return alert("Game already started");

        const newPlayer = createPlayerObj(localPlayerId, playerNameVal, false, colorVal);
        
        await db.runTransaction(async (t) => {
            const fresh = await t.get(lobbyRef);
            if (!fresh.exists) throw "Lobby gone";
            const data = fresh.data();
            const players = data.players;
            if (players.find(p => p.id === localPlayerId)) return; 
            if (players.length >= 10) throw "Lobby Full";
            
            // Auto-assign team if in team mode
            if (data.settings && data.settings.mode === 'TEAMS') {
                 const t1Count = players.filter(p => p.teamId === 0).length;
                 const t2Count = players.filter(p => p.teamId === 1).length;
                 newPlayer.teamId = t1Count <= t2Count ? 0 : 1;
            }
            
            players.push(newPlayer);
            t.update(lobbyRef, { players: players });
        });

        lobbyId = id;
        enterLobbyUI(lobbyId, false);
    }

    function createPlayerObj(id, name, isBot, color) {
        return {
            id: id,
            name: name,
            isBot: isBot,
            age: 0,
            xp: 0,
            gold: 300,
            hp: DEFAULT_SETTINGS.baseHp, 
            maxHp: DEFAULT_SETTINGS.baseHp,
            turrets: [], 
            targetId: null, 
            color: color || `hsl(${Math.random() * 360}, 70%, 50%)`,
            spawnQueue: [], 
            spawnTimer: 0, 
            _visualTimer: 0, 
            specialCooldown: 0,
            teamId: -1 // -1 for FFA, 0 or 1 for Teams
        };
    }
    
    async function kickPlayer(targetId) {
        if (!isHost || !lobbyId) return;
        const lobbyRef = getLobbyRef().doc(lobbyId);
        await db.runTransaction(async (t) => {
             const doc = await t.get(lobbyRef);
             if (!doc.exists) return;
             const data = doc.data();
             const newPlayers = data.players.filter(p => p.id !== targetId);
             t.update(lobbyRef, { players: newPlayers });
        });
    }
    
    async function switchTeam(playerId) {
        if (!lobbyId) return;
        const lobbyRef = getLobbyRef().doc(lobbyId);
        await db.runTransaction(async (t) => {
             const doc = await t.get(lobbyRef);
             if (!doc.exists) return;
             const data = doc.data();
             const players = data.players;
             const p = players.find(x => x.id === playerId);
             if(p) {
                 p.teamId = p.teamId === 0 ? 1 : 0;
                 t.update(lobbyRef, { players });
             }
        });
    }

    async function leaveLobby() {
        if (!lobbyId) return;
        const lobbyRef = getLobbyRef().doc(lobbyId);
        
        if (lobbyUnsub) lobbyUnsub();
        lobbyUnsub = null;
        
        await db.runTransaction(async (t) => {
             const doc = await t.get(lobbyRef);
             if (!doc.exists) return;
             const data = doc.data();
             const newPlayers = data.players.filter(p => p.id !== localPlayerId);
             if (newPlayers.length === 0) {
                 t.delete(lobbyRef);
             } else {
                 let updates = { players: newPlayers };
                 if (data.hostId === localPlayerId) {
                     updates.hostId = newPlayers[0].id; 
                 }
                 t.update(lobbyRef, updates);
             }
        });
        location.reload();
    }

    function updateLocalSettingUI(settings) {
        if(!settings) return;
        // Map settings to inputs
        const setVal = (id, val) => {
            const el = document.getElementById(id);
            if(el) {
                if(el.type === 'checkbox') el.checked = val;
                else el.value = val;
            }
        };
        
        setVal('set-mode', settings.mode);
        setVal('set-speed', settings.gameSpeed);
        setVal('set-cost', settings.unitCostMult);
        setVal('set-gold', settings.goldMult);
        setVal('set-xp', settings.xpMult);
        setVal('set-hp', settings.baseHp);
        setVal('set-levelup', settings.xpToLevelMult);
        setVal('set-pos', settings.teamPositioning);
        
        if (settings.teams) {
            setVal('set-t1-name', settings.teams[0].name);
            setVal('set-t1-color', settings.teams[0].color);
            setVal('set-t2-name', settings.teams[1].name);
            setVal('set-t2-color', settings.teams[1].color);
        }

        // Toggle Visibility based on Mode
        const teamSettingsDiv = document.getElementById('team-settings-panel');
        if (settings.mode === 'TEAMS') {
            teamSettingsDiv.classList.remove('hidden');
        } else {
            teamSettingsDiv.classList.add('hidden');
        }
    }

    async function saveSettingsFromUI() {
        if(!isHost || !lobbyId) return;
        
        const settings = {
            mode: document.getElementById('set-mode').value,
            gameSpeed: parseFloat(document.getElementById('set-speed').value),
            unitCostMult: parseFloat(document.getElementById('set-cost').value),
            goldMult: parseFloat(document.getElementById('set-gold').value),
            xpMult: parseFloat(document.getElementById('set-xp').value),
            baseHp: parseInt(document.getElementById('set-hp').value),
            xpToLevelMult: parseFloat(document.getElementById('set-levelup').value),
            teamPositioning: document.getElementById('set-pos').value,
            teams: [
                { name: document.getElementById('set-t1-name').value, color: document.getElementById('set-t1-color').value },
                { name: document.getElementById('set-t2-name').value, color: document.getElementById('set-t2-color').value }
            ]
        };
        
        getLobbyRef().doc(lobbyId).update({ settings });
    }
    
    function resetDefaults() {
        if(!isHost) return;
        updateLocalSettingUI(DEFAULT_SETTINGS);
        saveSettingsFromUI();
    }

    function enterLobbyUI(id, host) {
        isHost = host;
        showScreen('waiting-room');
        document.getElementById('display-lobby-id').innerText = id;
        
        // Setup Settings Inputs Listeners (only for Host)
        const inputs = document.querySelectorAll('#settings-panel input, #settings-panel select');
        inputs.forEach(inp => {
            if(host) {
                inp.disabled = false;
                inp.oninput = () => {
                    // Immediate UI update for sliders labels
                    // Debounced save
                    if(updateSettingsDebounce) clearTimeout(updateSettingsDebounce);
                    updateSettingsDebounce = setTimeout(saveSettingsFromUI, 500);
                };
            } else {
                inp.disabled = true;
            }
        });
        
        const rstBtn = document.getElementById('reset-btn');
        if(host) rstBtn.classList.remove('hidden'); else rstBtn.classList.add('hidden');

        if(!host) document.getElementById('start-btn').classList.add('hidden');
        if(!host) document.getElementById('add-bot-btn').classList.add('hidden');

        lobbyUnsub = getLobbyRef().doc(id).onSnapshot(doc => {
            if(!doc.exists) { alert("Lobby closed."); location.reload(); return; }
            const data = doc.data();
            
            const amIIn = data.players.find(p => p.id === localPlayerId);
            if (!amIIn) { alert("You have been kicked."); location.reload(); return; }

            isHost = (data.hostId === localPlayerId);
            if(isHost) {
                 document.getElementById('start-btn').classList.remove('hidden');
                 document.getElementById('add-bot-btn').classList.remove('hidden');
                 document.getElementById('reset-btn').classList.remove('hidden');
                 inputs.forEach(i => i.disabled = false);
            } else {
                 document.getElementById('start-btn').classList.add('hidden');
                 document.getElementById('add-bot-btn').classList.add('hidden');
                 document.getElementById('reset-btn').classList.add('hidden');
                 inputs.forEach(i => i.disabled = true);
            }

            // Sync Settings UI
            if (data.settings) {
                updateLocalSettingUI(data.settings);
            }

            // Render Player List
            const list = document.getElementById('player-list');
            list.innerHTML = data.players.map(p => {
                let extra = '';
                if (isHost && p.id !== localPlayerId) extra += `<button onclick="kickPlayer('${p.id}')" class="btn-danger ml-2">Kick</button>`;
                
                let teamBadge = '';
                if (data.settings && data.settings.mode === 'TEAMS') {
                    const teamIdx = p.teamId === undefined ? 0 : p.teamId;
                    const tConfig = data.settings.teams[teamIdx];
                    teamBadge = `<div class="cursor-pointer ml-2 px-2 py-0.5 text-xs rounded font-bold border border-white/20" 
                                style="background:${tConfig.color}; color:white; text-shadow:0 1px 2px black"
                                onclick="${isHost || p.id === localPlayerId ? `switchTeam('${p.id}')` : ''}"
                                title="Click to switch team">
                                ${tConfig.name}
                                </div>`;
                }

                return `
                <div class="flex items-center justify-between bg-gray-700 p-2 rounded mb-1">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full" style="background:${p.color}"></div>
                        <span>${p.name} ${p.isBot ? '(BOT)' : ''}</span>
                        ${teamBadge}
                    </div>
                    <div class="flex items-center">
                        ${p.id === data.hostId ? '<span class="text-xs text-yellow-500 mr-2">HOST</span>' : ''}
                        ${extra}
                    </div>
                </div>`;
            }).join('');

            if(data.status === 'playing' || data.status === 'paused') {
                startGame(data);
            } else if (data.status === 'finished') {
                if (gameState !== 'finished') {
                    gameState = 'finished';
                    let resultText = "GAME OVER";
                    let resultColor = "text-white";
                    
                    if (data.settings.mode === 'TEAMS') {
                         const myTeam = data.players.find(p=>p.id===localPlayerId)?.teamId;
                         const winTeam = data.winnerTeam;
                         if (myTeam === winTeam) { resultText = "VICTORY!"; resultColor = "text-yellow-400"; }
                         else { resultText = "DEFEAT"; resultColor = "text-red-500"; }
                    } else {
                         const amIWinner = data.winner?.id === localPlayerId;
                         resultText = amIWinner ? "VICTORY!" : "DEFEAT";
                         resultColor = amIWinner ? "text-yellow-400" : "text-red-500";
                    }

                    const overlay = document.createElement('div');
                    overlay.className = "absolute inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center z-50 pointer-events-auto";
                    overlay.innerHTML = `
                        <h1 class="text-6xl font-bold ${resultColor} mb-4">${resultText}</h1>
                        <p class="text-2xl text-white mb-8">Winner: ${data.winnerName || 'Unknown'}</p>
                        <button onclick="location.reload()" class="btn-primary">Back to Menu</button>
                    `;
                    document.body.appendChild(overlay);
                }
            }
        });
    }

    function copyLobbyId() {
        const idText = document.getElementById('display-lobby-id').innerText;
        const tempInput = document.createElement('input');
        tempInput.value = idText;
        document.body.appendChild(tempInput);
        tempInput.select();
        document.execCommand('copy');
        document.body.removeChild(tempInput);
    }

    async function addBot() {
        if(!isHost) return;
        const lobbyRef = getLobbyRef().doc(lobbyId);
        const doc = await lobbyRef.get();
        const data = doc.data();
        const players = data.players;
        if(players.length >= 10) return alert("Lobby full");
        
        let tid = -1;
        if (data.settings.mode === 'TEAMS') {
             const t1 = players.filter(p => p.teamId === 0).length;
             const t2 = players.filter(p => p.teamId === 1).length;
             tid = t1 <= t2 ? 0 : 1;
        }

        const bot = createPlayerObj('bot_' + Date.now(), "Bot " + Math.floor(Math.random()*100), true, `hsl(${Math.random() * 360}, 70%, 50%)`);
        bot.teamId = tid;
        
        players.push(bot);
        await lobbyRef.update({ players });
    }

    async function setGameStarted() {
        if(!isHost) return;
        // Validate Teams
        const doc = await getLobbyRef().doc(lobbyId).get();
        const d = doc.data();
        if (d.settings.mode === 'TEAMS') {
            const t1 = d.players.some(p => p.teamId === 0);
            const t2 = d.players.some(p => p.teamId === 1);
            if (!t1 || !t2) return alert("Need at least one player on each team!");
        }
        await getLobbyRef().doc(lobbyId).update({ status: 'playing' });
    }

    // --- Game Logic ---
    let simState = { players: [], units: [], projectiles: [], effects: [] };
    
    function startGame(initialData) {
        if(lobbyUnsub) lobbyUnsub();
        showScreen('game-screen');
        
        activeSettings = initialData.settings || DEFAULT_SETTINGS;
        
        canvas = document.getElementById('game-canvas');
        ctx = canvas.getContext('2d');
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        simState.players = initialData.players;
        
        // --- POSITIONING LOGIC ---
        const radius = GAME_DATA.mapRadius * 0.8;
        const center = { x: 0, y: 0 };
        
        // Sort players based on positioning settings
        let sortedPlayers = [...simState.players];
        if (activeSettings.mode === 'TEAMS' && activeSettings.teamPositioning === 'together') {
            sortedPlayers.sort((a, b) => a.teamId - b.teamId);
        } else if (activeSettings.mode === 'TEAMS' && activeSettings.teamPositioning === 'checkerboard') {
            // Interleave (0, 1, 0, 1...) handled by simple index assignment if balanced, but we just distribute evenly on circle
            // The natural order in lobby might be random, so let's separate them into two arrays and zipper merge
            const t0 = sortedPlayers.filter(p => p.teamId === 0);
            const t1 = sortedPlayers.filter(p => p.teamId === 1);
            sortedPlayers = [];
            const maxLen = Math.max(t0.length, t1.length);
            for(let i=0; i<maxLen; i++) {
                if(t0[i]) sortedPlayers.push(t0[i]);
                if(t1[i]) sortedPlayers.push(t1[i]);
            }
        }
        
        const angleStep = (Math.PI * 2) / sortedPlayers.length;
        
        sortedPlayers.forEach((p, i) => {
            // Find original player object in simState to update XYZ
            const originalP = simState.players.find(x => x.id === p.id);
            const angle = angleStep * i;
            originalP.x = center.x + Math.cos(angle) * radius;
            originalP.y = center.y + Math.sin(angle) * radius;
            
            // Apply Settings to Player Stats
            originalP.hp = activeSettings.baseHp;
            originalP.maxHp = activeSettings.baseHp;
            
            const ageData = GAME_DATA.ages[originalP.age];
            if(ageData && ageData.turret) {
                 originalP.turrets = [{ id: 'base_turret', typeId: ageData.turret.id, cooldown: 0, slot: 0 }];
            }
            if(originalP._visualTimer === undefined) originalP._visualTimer = 0;
        });

        // Input Listeners
        // ... (Same Input Logic as before)
        let isDragging = false;
        let lastPos = { x: 0, y: 0 };
        const getPos = (e) => {
            if (e.changedTouches) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        };
        const onDown = (e) => {
            if (e.button === 2) { 
                if (input.mode === 'ability') {
                    input.mode = 'select';
                    document.body.style.cursor = 'default';
                }
                return;
            }
            isDragging = false;
            const p = getPos(e);
            input.mouse.down = true; input.mouse.x = p.x; input.mouse.y = p.y; lastPos = p;
        };
        const onMove = (e) => {
            e.preventDefault(); 
            const p = getPos(e);
            input.mouse.x = p.x; input.mouse.y = p.y;
            if (input.mouse.down) {
                const dx = p.x - lastPos.x; const dy = p.y - lastPos.y;
                if (Math.abs(dx) > 2 || Math.abs(dy) > 2) isDragging = true;
                if (isDragging) { camera.x -= dx / camera.zoom; camera.y -= dy / camera.zoom; lastPos = p; }
            }
        };
        const onUp = (e) => {
            input.mouse.down = false;
            if (!isDragging && e.button === 0) handleInput();
            isDragging = false;
        };
        canvas.addEventListener('mousedown', onDown);
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseup', onUp);
        canvas.addEventListener('touchstart', onDown, {passive: false});
        canvas.addEventListener('touchmove', onMove, {passive: false});
        canvas.addEventListener('touchend', onUp);
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            camera.zoom *= (1 - e.deltaY * 0.001);
            camera.zoom = Math.max(0.2, Math.min(camera.zoom, 2.5));
        });
        window.addEventListener('contextmenu', e => e.preventDefault());

        const me = simState.players.find(p => p.id === localPlayerId);
        if (me) { camera.x = me.x; camera.y = me.y; }

        if(isHost) {
            requestAnimationFrame(hostGameLoop);
            setInterval(hostSync, 200); 
        } else {
            getLobbyRef().doc(lobbyId).onSnapshot(doc => {
                if(!doc.exists) return;
                const d = doc.data();
                lastUpdateReceived = Date.now();
                
                if(d.stateJSON) {
                    const parsed = JSON.parse(d.stateJSON);
                    // Sync Players
                    d.players.forEach(serverPlayer => {
                        const localP = simState.players.find(p => p.id === serverPlayer.id);
                        if (localP) {
                            localP.gold = serverPlayer.gold;
                            localP.xp = serverPlayer.xp;
                            localP.hp = serverPlayer.hp;
                            localP.age = serverPlayer.age;
                            
                            const oldHead = localP.spawnQueue && localP.spawnQueue.length > 0 ? localP.spawnQueue[0].reqId : null;
                            const newHead = serverPlayer.spawnQueue && serverPlayer.spawnQueue.length > 0 ? serverPlayer.spawnQueue[0].reqId : null;
                            
                            if (oldHead !== newHead && newHead) {
                                const stats = getUnitStats(localP.age, serverPlayer.spawnQueue[0].unitId);
                                if (stats) localP._visualTimer = stats.delay;
                                else localP._visualTimer = serverPlayer.spawnTimer;
                            } else if (serverPlayer.spawnQueue.length > 0) {
                                if (Math.abs((localP._visualTimer || 0) - serverPlayer.spawnTimer) > 0.3) {
                                    localP._visualTimer = serverPlayer.spawnTimer;
                                }
                            } else {
                                localP._visualTimer = 0;
                            }
                            localP.spawnQueue = serverPlayer.spawnQueue;
                        }
                    });
                    
                    if (simState.players.length === 0) simState.players = d.players;

                    const me = simState.players.find(p => p.id === localPlayerId);
                    if(me && me.spawnQueue) {
                        const serverQueueIds = new Set(me.spawnQueue.map(i => i.reqId));
                        pendingQueue = pendingQueue.filter(pending => !serverQueueIds.has(pending.reqId));
                    }
                    
                    simState.projectiles = parsed.projectiles;
                    simState.effects = parsed.effects;
                    
                    parsed.units.forEach(serverUnit => {
                        if (renderState.units.has(serverUnit.id)) {
                            const u = renderState.units.get(serverUnit.id);
                            u.targetX = serverUnit.x; u.targetY = serverUnit.y;
                            u.hp = serverUnit.hp; u.maxHp = serverUnit.maxHp;
                        } else {
                            renderState.units.set(serverUnit.id, { ...serverUnit, x: serverUnit.x, y: serverUnit.y, targetX: serverUnit.x, targetY: serverUnit.y });
                        }
                    });
                    const serverIds = new Set(parsed.units.map(u => u.id));
                    for (let [id, u] of renderState.units) { if (!serverIds.has(id)) renderState.units.delete(id); }
                    simState.units = Array.from(renderState.units.values());
                }
            });
            requestAnimationFrame(clientRenderLoop);
        }
        updateUI();
    }

    // --- Host Simulation ---
    const TICK_RATE = 1 / 30; 
    let lastTime = performance.now();
    let accumulator = 0;
    let syncTimer = 0;

    function hostGameLoop(time) {
        if (gameState === 'finished') return;
        let deltaTime = (time - lastTime) / 1000;
        lastTime = time;
        if (deltaTime > 0.25) deltaTime = 0.25;
        accumulator += deltaTime;
        while (accumulator >= TICK_RATE) {
            updateHostLogic(TICK_RATE);
            accumulator -= TICK_RATE;
        }
        syncTimer += deltaTime;
        if (syncTimer > 0.1) {
            hostSyncState();
            syncTimer = 0;
        }
        renderGame(0);
        updateUI();
        requestAnimationFrame(hostGameLoop);
    }

    function updateHostLogic(dt) {
        // Process Actions
        getLobbyRef().doc(lobbyId).collection('requests').get().then(snap => {
            snap.forEach(doc => { processAction(doc.data()); doc.ref.delete(); });
        });

        // Player Logic
        simState.players.forEach(p => {
            if (p.hp <= 0) { p.spawnQueue = []; return; }
            if (p.isBot) runBotLogic(p, dt);
            if (p.specialCooldown > 0) p.specialCooldown -= dt;

            if (p.spawnQueue.length > 0) {
                p.spawnTimer -= dt * activeSettings.gameSpeed; // SPEED MULTIPLIER
                if (p.spawnTimer <= 0) {
                    const item = p.spawnQueue.shift();
                    spawnUnitReal(p.id, item.unitId);
                    if (p.spawnQueue.length > 0) {
                        const stats = getUnitStats(p.age, p.spawnQueue[0].unitId);
                        p.spawnTimer = stats ? stats.delay : 1.0;
                    } else {
                        p.spawnTimer = 0;
                    }
                }
            }
        });

        // Unit Logic
        simState.units = simState.units.filter(u => u.hp > 0);
        simState.units.forEach(u => updateUnit(u, dt));

        // Turret Logic
        simState.players.forEach(p => { if (p.hp > 0) updateTurrets(p, dt); });

        // Projectiles
        simState.projectiles = simState.projectiles.filter(p => {
            p.x += p.vx * dt * 400 * activeSettings.gameSpeed; 
            p.y += p.vy * dt * 400 * activeSettings.gameSpeed;
            
            let hit = false;
            // FILTER TARGETS: Only Enemies
            const targets = simState.units.filter(u => isEnemy(p.ownerId, u.ownerId));
            
            for (let t of targets) {
                if (dist(p.x, p.y, t.x, t.y) < GAME_DATA.unitCollisionRadius + 5) {
                    t.hp -= p.damage;
                    hit = true;
                    simState.effects.push({x: t.x, y: t.y, type: 'hit', timer: 0.5});
                    if (t.hp <= 0) awardKill(p.ownerId, t);
                    break;
                }
            }
            if (!hit) {
                simState.players.forEach(pl => {
                    if (isEnemy(p.ownerId, pl.id) && pl.hp > 0 && dist(p.x, p.y, pl.x, pl.y) < GAME_DATA.baseRadius) {
                        pl.hp -= p.damage;
                        hit = true;
                        if (pl.hp <= 0) pl.hp = 0; 
                    }
                });
            }
            return !hit && Math.abs(p.x) < 2000 && Math.abs(p.y) < 2000; 
        });

        simState.effects = simState.effects.filter(e => { e.timer -= dt; return e.timer > 0; });
        
        // --- WIN CONDITION ---
        checkWinCondition();
    }

    function checkWinCondition() {
        const alivePlayers = simState.players.filter(p => p.hp > 0);
        
        if (activeSettings.mode === 'TEAMS') {
             // Check if only one team has alive players
             const teamsAlive = new Set(alivePlayers.map(p => p.teamId));
             
             if (teamsAlive.size <= 1 && simState.players.length > 1) {
                  // Wait a moment to ensure it's not a draw or just initialization glitch
                  // For simplicity, immediate win
                  if (teamsAlive.size === 1) {
                      const winTeamId = Array.from(teamsAlive)[0];
                      const winTeamName = activeSettings.teams[winTeamId].name;
                      finishGame({ winnerTeam: winTeamId, winnerName: winTeamName });
                  } else if (teamsAlive.size === 0) {
                      finishGame({ winnerName: "Draw" });
                  }
             }
        } else {
             // FFA
             if (alivePlayers.length <= 1 && simState.players.length > 1) {
                 const winner = alivePlayers[0];
                 finishGame({ winner: { id: winner?.id, name: winner?.name }, winnerName: winner?.name || "None" });
             }
        }
    }

    function finishGame(resultData) {
        gameState = 'finished';
        getLobbyRef().doc(lobbyId).update({
            status: 'finished',
            ...resultData
        });
    }

    function isEnemy(id1, id2) {
        if (id1 === id2) return false;
        if (activeSettings.mode === 'TEAMS') {
            const p1 = simState.players.find(p => p.id === id1);
            const p2 = simState.players.find(p => p.id === id2);
            if (p1 && p2 && p1.teamId === p2.teamId) return false;
        }
        return true;
    }

    function hostSyncState() {
        if(gameState === 'finished') return;
        const stateJSON = JSON.stringify({
            units: simState.units.map(u => ({
                id: u.id, ownerId: u.ownerId, typeId: u.typeId, 
                x: Math.round(u.x), y: Math.round(u.y), 
                hp: u.hp, maxHp: u.maxHp, icon: u.icon
            })),
            projectiles: simState.projectiles,
            effects: simState.effects
        });
        getLobbyRef().doc(lobbyId).update({ 
            stateJSON: stateJSON,
            lastHeartbeat: firebase.firestore.FieldValue.serverTimestamp()
        });
    }

    function hostSync() {
        if(gameState === 'finished') return;
        getLobbyRef().doc(lobbyId).update({ players: simState.players });
    }

    function getUnitStats(ageIdx, unitId) {
        for (const age of GAME_DATA.ages) {
            const u = age.units.find(x => x.id === unitId);
            if (u) return u;
        }
        return null;
    }

    function runBotLogic(bot, dt) {
        // Target Logic
        if (!bot.targetId || Math.random() < 0.01) {
            const enemies = simState.players.filter(p => isEnemy(bot.id, p.id) && p.hp > 0);
            if (enemies.length > 0) {
                bot.targetId = enemies[Math.floor(Math.random() * enemies.length)].id;
            }
        }
        
        // Upgrade Logic
        const nextAge = GAME_DATA.ages[bot.age + 1];
        const reqXp = nextAge ? nextAge.xpReq * activeSettings.xpToLevelMult : Infinity;
        
        if (nextAge && bot.xp >= reqXp) {
             bot.age++;
             bot.hp = Math.min(bot.hp + 500, activeSettings.baseHp); // Healing on age up restricted to base settings
             bot.maxHp = activeSettings.baseHp;
             bot.turrets = [{ id: 'base_turret', typeId: GAME_DATA.ages[bot.age].turret.id, cooldown: 0, slot: 0 }];
        }
        
        // Buy Logic
        const ageData = GAME_DATA.ages[bot.age];
        if (bot.spawnQueue.length < 3 && Math.random() < 0.05) {
            const unitOpts = ageData.units;
            const pick = unitOpts[Math.floor(Math.random() * unitOpts.length)];
            const actualCost = Math.floor(pick.cost * activeSettings.unitCostMult);
            
            if (bot.gold >= actualCost) {
                bot.gold -= actualCost;
                bot.spawnQueue.push({ reqId: 'bot_'+Math.random(), unitId: pick.id });
                if (bot.spawnQueue.length === 1) bot.spawnTimer = pick.delay;
            }
        }
        // Special Logic
        if (bot.specialCooldown <= 0 && ageData.special && bot.targetId) {
             const t = simState.players.find(p => p.id === bot.targetId);
             if (t) useSpecial(bot.id, t.x, t.y);
        }
    }

    function updateUnit(u, dt) {
        const owner = simState.players.find(p => p.id === u.ownerId);
        
        if(u.cooldownTimer > 0) u.cooldownTimer -= dt * 60 * activeSettings.gameSpeed;

        // Auto-Targeting
        let targetPlayer = simState.players.find(p => p.id === u.targetId);
        // Verify target is valid enemy
        if (!targetPlayer || targetPlayer.hp <= 0 || !isEnemy(u.ownerId, targetPlayer.id)) {
            // Find new target
            let close = null;
            let minDist = Infinity;
            simState.players.forEach(p => {
                if (isEnemy(u.ownerId, p.id) && p.hp > 0) {
                    const d = dist(u.x, u.y, p.x, p.y);
                    if (d < minDist) { minDist = d; close = p; }
                }
            });
            if (close) { u.targetId = close.id; targetPlayer = close; }
            else { return; } // No enemies
        }

        let enemy = null;
        let enemyDist = Infinity;
        
        // Check for units in range
        for (let other of simState.units) {
            if (isEnemy(u.ownerId, other.ownerId)) {
                const d = dist(u.x, u.y, other.x, other.y);
                const combinedRadii = GAME_DATA.unitCollisionRadius * 2;
                const maxRange = Math.max(u.meleeRange, u.rangedRange);
                if (d <= maxRange + combinedRadii && d < enemyDist) {
                    enemyDist = d;
                    enemy = other;
                }
            }
        }
        
        // Check for base in range if no unit closer
        if (!enemy) {
             const d = dist(u.x, u.y, targetPlayer.x, targetPlayer.y);
             const baseRadius = GAME_DATA.baseRadius;
             const maxRange = Math.max(u.meleeRange, u.rangedRange);
             if (d <= maxRange + GAME_DATA.unitCollisionRadius + baseRadius) {
                 enemy = { type: 'base', x: targetPlayer.x, y: targetPlayer.y, id: targetPlayer.id, radius: baseRadius };
                 enemyDist = d;
             }
        }

        if (enemy) {
            const enemyRadius = enemy.type === 'base' ? GAME_DATA.baseRadius : GAME_DATA.unitCollisionRadius;
            const isMeleeRange = enemyDist <= u.meleeRange + GAME_DATA.unitCollisionRadius + enemyRadius;
            const isRangedRange = u.rangedDmg > 0 && enemyDist <= u.rangedRange + GAME_DATA.unitCollisionRadius + enemyRadius;

            if (u.cooldownTimer <= 0) {
                if (isMeleeRange && u.meleeDmg > 0) {
                    if (enemy.type === 'base') {
                        const p = simState.players.find(pl => pl.id === enemy.id);
                        if(p) p.hp -= u.meleeDmg;
                    } else {
                        enemy.hp -= u.meleeDmg;
                        if(enemy.hp <= 0) awardKill(u.ownerId, enemy);
                    }
                    simState.effects.push({x: enemy.x, y: enemy.y, type: 'hit', timer: 0.2});
                    u.cooldownTimer = 60; 
                } else if (isRangedRange) {
                    simState.projectiles.push({
                        x: u.x, y: u.y, 
                        vx: (enemy.x - u.x) / dist(u.x, u.y, enemy.x, enemy.y),
                        vy: (enemy.y - u.y) / dist(u.x, u.y, enemy.x, enemy.y),
                        damage: u.rangedDmg,
                        ownerId: u.ownerId
                    });
                    u.cooldownTimer = 60;
                } else {
                    moveUnit(u, targetPlayer, dt);
                }
            }
        } else {
            moveUnit(u, targetPlayer, dt);
        }
    }

    function moveUnit(u, targetPlayer, dt) {
        let canMove = true;
        const step = activeSettings.gameSpeed * dt * 50; 
        const angle = Math.atan2(targetPlayer.y - u.y, targetPlayer.x - u.x);
        const nextX = u.x + Math.cos(angle) * step;
        const nextY = u.y + Math.sin(angle) * step;

        // Collision Check
        for (let other of simState.units) {
            if (other.id !== u.id) {
                const d = dist(nextX, nextY, other.x, other.y);
                if (d < GAME_DATA.unitCollisionRadius * 2) {
                    const dx = other.x - u.x; const dy = other.y - u.y;
                    const dot = dx * Math.cos(angle) + dy * Math.sin(angle);
                    if (dot > 0) { canMove = false; break; }
                }
            }
        }
        if (canMove) { u.x = nextX; u.y = nextY; }
    }

    function updateTurrets(p, dt) {
        p.turrets.forEach(t => {
            const tData = GAME_DATA.ages.find(a => a.turret && a.turret.id === t.typeId)?.turret;
            if (!tData) return;
            
            if (t.cooldown > 0) t.cooldown -= dt * 60 * activeSettings.gameSpeed;
            
            if (t.cooldown <= 0) {
                let target = null;
                let minD = tData.range;
                for (let u of simState.units) {
                    if (isEnemy(p.id, u.ownerId)) {
                        const d = dist(p.x, p.y, u.x, u.y);
                        if (d < minD) { minD = d; target = u; }
                    }
                }
                if (target) {
                    simState.projectiles.push({
                        x: p.x, y: p.y,
                        vx: (target.x - p.x) / dist(p.x, p.y, target.x, target.y),
                        vy: (target.y - p.y) / dist(p.x, p.y, target.x, target.y),
                        damage: tData.damage,
                        ownerId: p.id
                    });
                    t.cooldown = tData.cooldown;
                }
            }
        });
    }

    function spawnUnitReal(playerId, unitId) {
        const p = simState.players.find(x => x.id === playerId);
        const stats = getUnitStats(p.age, unitId);
        
        let spawnX = p.x; let spawnY = p.y;
        
        // Spawn towards target if exists, else towards center
        let targetAngle = 0;
        if (p.targetId) {
            const target = simState.players.find(tp => tp.id === p.targetId);
            if (target) targetAngle = Math.atan2(target.y - p.y, target.x - p.x);
        } else {
             targetAngle = Math.atan2(-p.y, -p.x);
        }
        
        spawnX += Math.cos(targetAngle) * (GAME_DATA.baseRadius + 20);
        spawnY += Math.sin(targetAngle) * (GAME_DATA.baseRadius + 20);

        simState.units.push({
            id: Math.random().toString(36),
            ownerId: p.id,
            typeId: unitId,
            x: spawnX, y: spawnY,
            hp: stats.hp, maxHp: stats.hp,
            meleeDmg: stats.meleeDmg, rangedDmg: stats.rangedDmg,
            meleeRange: stats.meleeRange, rangedRange: stats.rangedRange,
            cooldownTimer: 0,
            targetId: p.targetId,
            icon: stats.icon,
            cost: stats.cost
        });
    }

    function useSpecial(playerId, x, y) {
        const p = simState.players.find(x => x.id === playerId);
        const age = GAME_DATA.ages[p.age];
        if(!age.special) return;
        if (p.specialCooldown > 0) return;

        p.specialCooldown = age.special.cooldown;
        simState.effects.push({x, y, type: 'explosion', radius: age.special.radius, timer: 1.0});
        
        // Friendly Fire Check for Special? Usually specials hurt everyone or just enemies. Let's make it safe for teammates.
        simState.units.forEach(u => {
            if (isEnemy(playerId, u.ownerId) && dist(u.x, u.y, x, y) < age.special.radius) {
                u.hp -= age.special.damage;
                if(u.hp <= 0) awardKill(playerId, u);
            }
        });
    }

    function awardKill(killerId, victimUnit) {
        const killer = simState.players.find(p => p.id === killerId);
        if (killer && victimUnit.cost) {
            killer.gold += Math.ceil(victimUnit.cost * 1.3 * activeSettings.goldMult);
            killer.xp += Math.floor(victimUnit.cost * 1.0 * activeSettings.xpMult);
        }
    }

    function processAction(action) {
        if (action.type === 'queueUnit') {
            const p = simState.players.find(x => x.id === action.playerId);
            if (p && p.hp > 0) {
                 const stats = getUnitStats(p.age, action.unitId);
                 const cost = Math.floor(stats.cost * activeSettings.unitCostMult);
                 if (stats && p.gold >= cost) {
                     p.gold -= cost;
                     p.spawnQueue.push({ unitId: action.unitId, reqId: action.reqId });
                     if (p.spawnQueue.length === 1) p.spawnTimer = stats.delay;
                 }
            }
        } else if (action.type === 'setTarget') {
            const p = simState.players.find(x => x.id === action.playerId);
            if (p && isEnemy(p.id, action.targetId)) {
                p.targetId = action.targetId;
            }
        } else if (action.type === 'upgrade') {
            const p = simState.players.find(x => x.id === action.playerId);
            if (p) {
                const nextAge = GAME_DATA.ages[p.age + 1];
                const xpReq = nextAge ? nextAge.xpReq * activeSettings.xpToLevelMult : Infinity;
                if (nextAge && p.xp >= xpReq) {
                    p.age++;
                    p.hp = Math.min(p.hp + 500, activeSettings.baseHp);
                    p.maxHp = activeSettings.baseHp;
                    p.turrets = [{ id: 'base_turret', typeId: GAME_DATA.ages[p.age].turret.id, cooldown: 0, slot: 0 }];
                }
            }
        } else if (action.type === 'special') {
             useSpecial(action.playerId, action.x, action.y);
        }
    }

    // --- Client Interaction ---
    let lastClientTime = performance.now();
    
    function clientRenderLoop(time) {
        const dt = (time - lastClientTime) / 1000;
        lastClientTime = time;
        
        // Timer Sync
        simState.players.forEach(p => {
            if (p._visualTimer > 0) {
                p._visualTimer -= dt * activeSettings.gameSpeed;
                if(p._visualTimer < 0) p._visualTimer = 0;
            }
        });

        renderGame(dt);
        updateUI();
        if (gameState !== 'finished') requestAnimationFrame(clientRenderLoop);
    }

    function sendAction(data) {
        const now = Date.now();
        const reqId = localPlayerId + '_' + now + '_' + Math.random();

        if (data.type === 'queueUnit') {
            lastUnitBuyTime = now;
            if (!isHost) {
                const p = simState.players.find(x => x.id === localPlayerId);
                const stats = getUnitStats(p.age, data.unitId);
                const cost = Math.floor(stats.cost * activeSettings.unitCostMult);
                
                if (p && stats && p.gold >= cost) {
                    pendingQueue.push({ unitId: data.unitId, reqId: reqId, timestamp: now, cost: cost, startTime: now });
                    updateUI();
                }
            }
        }
        const payload = { ...data, playerId: localPlayerId, reqId: reqId };
        if (isHost) processAction(payload);
        else getLobbyRef().doc(lobbyId).collection('requests').add({ ...payload, timestamp: firebase.firestore.FieldValue.serverTimestamp() });
    }

    function handleInput() {
        const rect = canvas.getBoundingClientRect();
        const mx = (input.mouse.x - rect.left - canvas.width/2) / camera.zoom + camera.x;
        const my = (input.mouse.y - rect.top - canvas.height/2) / camera.zoom + camera.y;

        if (input.mode === 'ability') {
            sendAction({ type: 'special', x: mx, y: my });
            input.mode = 'select'; document.body.style.cursor = 'default';
            return;
        }

        let clickedBase = null;
        simState.players.forEach(p => { if (dist(mx, my, p.x, p.y) < GAME_DATA.baseRadius) clickedBase = p; });

        if (clickedBase && clickedBase.id !== localPlayerId) {
            // Check friendly fire for target setting
            if (activeSettings.mode === 'TEAMS') {
                const me = simState.players.find(p=>p.id===localPlayerId);
                if (me.teamId === clickedBase.teamId) {
                    // Trying to target teammate
                    return; 
                }
            }
            sendAction({ type: 'setTarget', targetId: clickedBase.id });
        }
    }

    // --- Rendering ---
    function renderGame(dt) {
        if (!dt || dt > 0.5) dt = 0.016;

        ctx.fillStyle = '#1a1a1a'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x, -camera.y);

        // Map Bounds
        ctx.strokeStyle = '#444'; ctx.lineWidth = 5; ctx.beginPath();
        ctx.arc(0, 0, GAME_DATA.mapRadius, 0, Math.PI * 2); ctx.stroke();

        simState.players.forEach(p => {
            if (p.hp <= 0) {
                 ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(p.x, p.y, GAME_DATA.baseRadius, 0, Math.PI*2); ctx.fill();
                 return;
            }
            
            const me = simState.players.find(me => me.id === localPlayerId);
            if (me && me.targetId === p.id) {
                ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(p.x, p.y, GAME_DATA.baseRadius + 10, 0, Math.PI*2); ctx.stroke();
            }

            // DETERMINE COLOR
            let renderColor = p.color;
            if (activeSettings.mode === 'TEAMS' && p.teamId !== undefined && p.teamId !== -1) {
                renderColor = activeSettings.teams[p.teamId].color;
            }

            ctx.fillStyle = renderColor;
            ctx.beginPath(); ctx.arc(p.x, p.y, GAME_DATA.baseRadius, 0, Math.PI*2); ctx.fill();
            
            if(p.turrets.length > 0) {
                const tur = p.turrets[0];
                const tData = GAME_DATA.ages.find(a=>a.turret.id===tur.typeId).turret;
                ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(p.x, p.y, 30, 0, Math.PI*2); ctx.fill(); 
                ctx.fillStyle = '#fff'; ctx.font = '36px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(tData.icon, p.x, p.y);
            }

            drawBar(p.x, p.y - GAME_DATA.baseRadius - 15, 120, 12, p.hp, p.maxHp, '#0f0');
            ctx.fillStyle = '#fff'; ctx.font = '22px Arial'; ctx.fillText(p.name, p.x, p.y - GAME_DATA.baseRadius - 40);
        });

        const unitsToDraw = isHost ? simState.units : Array.from(renderState.units.values());
        unitsToDraw.forEach(u => {
            if (!isHost) {
                const t = 1.0 - Math.pow(0.001, dt); 
                u.x += (u.targetX - u.x) * t; u.y += (u.targetY - u.y) * t;
                if (dist(u.x, u.y, u.targetX, u.targetY) > 60) { u.x = u.targetX; u.y = u.targetY; }
            }

            const p = simState.players.find(pl => pl.id === u.ownerId);
            let color = '#fff';
            if (p) {
                 if (activeSettings.mode === 'TEAMS' && p.teamId !== undefined && p.teamId !== -1) {
                     color = activeSettings.teams[p.teamId].color;
                 } else {
                     color = p.color;
                 }
            }
            
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(u.x, u.y, 28, 0, Math.PI*2); ctx.fill();
            ctx.font = '44px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(u.icon, u.x, u.y);
            drawBar(u.x, u.y - 48, 48, 8, u.hp, u.maxHp, '#0f0');
        });

        simState.projectiles.forEach(p => {
            if (!isHost) { p.x += p.vx * dt * 400 * activeSettings.gameSpeed; p.y += p.vy * dt * 400 * activeSettings.gameSpeed; }
            ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI*2); ctx.fill();
        });
        
        simState.effects.forEach(e => {
            if (e.type === 'hit') { ctx.fillStyle = `rgba(255, 255, 255, ${e.timer * 2})`; ctx.beginPath(); ctx.arc(e.x, e.y, 20, 0, Math.PI*2); ctx.fill(); }
            else if (e.type === 'explosion') { ctx.fillStyle = `rgba(255, 100, 0, ${e.timer})`; ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill(); }
        });

        if (input.mode === 'ability') {
            const me = simState.players.find(x => x.id === localPlayerId);
            const age = GAME_DATA.ages[me.age];
            if(age && age.special) {
                const rect = canvas.getBoundingClientRect();
                const wx = (input.mouse.x - canvas.width/2) / camera.zoom + camera.x;
                const wy = (input.mouse.y - canvas.height/2) / camera.zoom + camera.y;
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(wx, wy, age.special.radius, 0, Math.PI*2); ctx.stroke(); ctx.fill();
            }
        }
        ctx.restore();
    }

    function drawBar(x, y, w, h, val, max, color) {
        ctx.fillStyle = '#000'; ctx.fillRect(x - w/2, y, w, h);
        ctx.fillStyle = color; const fill = Math.max(0, (val / max) * w); ctx.fillRect(x - w/2, y, fill, h);
    }

    function updateUI() {
        const p = simState.players.find(x => x.id === localPlayerId);
        if (!p) return;

        const ageIndex = p.age;
        const ageData = GAME_DATA.ages[ageIndex];
        const nextAge = GAME_DATA.ages[ageIndex + 1];

        let displayGold = p.gold;
        if (!isHost) pendingQueue.forEach(req => { displayGold -= req.cost; });
        
        document.getElementById('stats-gold').innerText = Math.floor(Math.max(0, displayGold));
        document.getElementById('stats-xp').innerText = Math.floor(p.xp);
        
        const queueDiv = document.getElementById('queue-bar');
        let displayQueue = p.spawnQueue ? [...p.spawnQueue] : [];
        const mappedPending = pendingQueue.map(pq => ({ unitId: pq.unitId, isPending: true, startTime: pq.startTime }));
        displayQueue = displayQueue.concat(mappedPending);

        if (displayQueue.length > 0) {
            queueDiv.classList.remove('hidden');
            queueDiv.innerHTML = displayQueue.map((item, idx) => {
                const uStats = getUnitStats(p.age, item.unitId);
                if (!uStats) return '';
                let progressHtml = '';
                if (idx === 0) {
                    let pct = 0;
                    if (item.isPending) {
                        const elapsed = (Date.now() - item.startTime) / 1000;
                        pct = Math.min(100, Math.max(0, (elapsed / (uStats.delay / activeSettings.gameSpeed)) * 100)); // Speed
                    } else if (isHost) {
                        pct = Math.min(100, Math.max(0, (1 - (p.spawnTimer / (uStats.delay))) * 100));
                    } else {
                        pct = Math.min(100, Math.max(0, (1 - (p._visualTimer / (uStats.delay))) * 100));
                    }
                    progressHtml = `<div class="queue-progress" style="width: ${pct}%"></div>`;
                } else {
                     progressHtml = `<div class="queue-progress" style="width: 0%"></div>`;
                }
                const opacity = item.isPending ? 'opacity-70' : '';
                return `<div class="queue-item ${opacity}">${uStats.icon}${progressHtml}</div>`;
            }).join('');
        } else {
            queueDiv.classList.add('hidden'); queueDiv.innerHTML = '';
        }

        const unitContainer = document.getElementById('unit-bar');
        // Simple dirty check to rebuild units if age changes
        const ageAttr = unitContainer.getAttribute('data-age');
        if (ageAttr !== String(ageIndex)) {
            unitContainer.setAttribute('data-age', ageIndex);
            unitContainer.innerHTML = ageData.units.map(u => {
                // Pre-calculate cost with multiplier for display
                const cost = Math.floor(u.cost * activeSettings.unitCostMult);
                return `
                <div id="btn-unit-${u.id}" class="unit-card relative w-24 h-24 rounded cursor-pointer flex flex-col items-center justify-center" 
                     onclick="sendAction({type: 'queueUnit', unitId: '${u.id}'})">
                    <span class="text-5xl pointer-events-none">${u.icon}</span> 
                    <span class="text-base text-yellow-400 font-bold pointer-events-none">$${cost}</span>
                    <div class="tooltip pointer-events-none">
                        <b class="text-yellow-400 text-xl">${u.name}</b><br/>
                        <div class="grid grid-cols-2 gap-2 mt-1">
                            <span>‚ù§Ô∏è HP: ${u.hp}</span>
                            <span>‚è±Ô∏è Train: ${u.delay}s</span>
                            <span>‚öîÔ∏è Melee: ${u.meleeDmg} (${u.meleeRange})</span>
                            <span>üèπ Range: ${u.rangedDmg} (${u.rangedRange})</span>
                        </div>
                    </div>
                </div>
            `}).join('');
            
            // Special button Logic...
            const specialBtn = document.getElementById('special-btn');
            if (ageData.special) {
                specialBtn.innerHTML = `<span class="pointer-events-none text-4xl">‚≠ê</span><span class="text-sm pointer-events-none">${ageData.special.name}</span><div id="special-cd-overlay" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center text-white font-bold hidden text-2xl"></div>`;
                specialBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-800');
                specialBtn.classList.add('bg-purple-900', 'border-purple-500', 'hover:bg-purple-800');
            } else {
                specialBtn.innerHTML = 'Locked';
                specialBtn.classList.add('opacity-50', 'cursor-not-allowed', 'bg-gray-800');
            }
        }

        // Update CD Overlay
        const cdOverlay = document.getElementById('special-cd-overlay');
        const specialBtn = document.getElementById('special-btn');
        if (p.specialCooldown > 0 && cdOverlay) {
             cdOverlay.classList.remove('hidden'); cdOverlay.innerText = Math.ceil(p.specialCooldown);
             specialBtn.onclick = null; specialBtn.classList.add('cursor-not-allowed');
        } else if (cdOverlay) {
             cdOverlay.classList.add('hidden');
             specialBtn.onclick = () => { input.mode = 'ability'; document.body.style.cursor = 'crosshair'; };
             specialBtn.classList.remove('cursor-not-allowed');
        }

        ageData.units.forEach(u => {
            const btn = document.getElementById(`btn-unit-${u.id}`);
            const cost = Math.floor(u.cost * activeSettings.unitCostMult);
            if (btn) {
                if (displayGold < cost) btn.classList.add('disabled'); else btn.classList.remove('disabled');
            }
        });

        const upgradeBtn = document.getElementById('upgrade-btn');
        if (nextAge) {
            upgradeBtn.classList.remove('hidden');
            const reqXp = nextAge.xpReq * activeSettings.xpToLevelMult;
            const canAfford = p.xp >= reqXp;
            if (canAfford) {
                upgradeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                upgradeBtn.onclick = () => { sendAction({type: 'upgrade'}); };
            } else {
                upgradeBtn.classList.add('opacity-50', 'cursor-not-allowed');
                upgradeBtn.onclick = null;
            }
            upgradeBtn.innerHTML = `Evolve to ${nextAge.name}<br/><span class="text-xs">${Math.ceil(reqXp)} XP</span>`;
        } else {
            upgradeBtn.classList.add('hidden');
        }
        
        const targetStatus = document.getElementById('target-status');
        if (p.targetId) {
            const t = simState.players.find(x => x.id === p.targetId);
            targetStatus.innerText = `Target: ${t ? t.name : 'Unknown'}`;
            targetStatus.classList.remove('text-red-400', 'animate-pulse'); targetStatus.classList.add('text-white');
        } else {
            targetStatus.innerText = "Click Base to Target";
            targetStatus.classList.add('text-red-400', 'animate-pulse'); targetStatus.classList.remove('text-white');
        }
    }

    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    function dist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)**2 + (y2-y1)**2); }
    window.addEventListener('DOMContentLoaded', initApp);
</script>

<!-- === UI LAYOUT === -->
<div id="lobby-screen" class="screen w-full h-full flex flex-row items-center justify-center relative bg-gray-900 gap-8">
    <div class="absolute bottom-4 right-4 text-gray-600 text-sm">Build: <span id="version-display"></span></div>
    <div class="glass-panel p-8 rounded-xl max-w-md w-full text-center">
        <h1 class="text-5xl font-bold mb-6 text-yellow-500">Age of War: FFA</h1>
        <div id="auth-status" class="mb-6 text-base text-yellow-500 animate-pulse">Connecting...</div>
        <div class="flex flex-col gap-4">
            <input id="lobby-name" type="text" placeholder="Your Name" class="bg-gray-800 border border-gray-600 p-4 rounded text-white text-xl">
            <div class="flex items-center gap-4 bg-gray-800 p-3 rounded border border-gray-600">
                <span class="text-lg text-gray-300">Base Color:</span>
                <input id="player-color" type="color" value="#ff0000" class="flex-1">
            </div>
            <div class="flex items-center gap-2 justify-center text-gray-400 mb-2">
                 <input type="checkbox" id="is-private-lobby"> <label for="is-private-lobby">Private Game (Code Only)</label>
            </div>
            <button onclick="createLobby()" class="btn-primary w-full py-4 text-xl">Create New Game</button>
            <div class="flex gap-2 mt-4">
                <input id="lobby-id-input" type="text" placeholder="CODE" class="bg-gray-800 border border-gray-600 p-3 rounded flex-1 text-white text-base text-center uppercase tracking-widest">
                <button onclick="joinLobby()" class="bg-blue-600 hover:bg-blue-500 text-white px-6 rounded font-bold text-lg">Join</button>
            </div>
        </div>
    </div>
    <div class="glass-panel p-6 rounded-xl w-80 h-96 flex flex-col">
        <h2 class="text-xl font-bold text-gray-300 mb-4 border-b border-gray-600 pb-2">Public Games</h2>
        <div id="active-lobbies-list" class="flex-1 overflow-y-auto pr-2"><div class="text-gray-500 text-sm text-center mt-10">Loading...</div></div>
    </div>
</div>

<div id="waiting-room" class="screen hidden w-full h-full flex items-center justify-center bg-gray-900 p-8">
    <div class="flex gap-8 w-full max-w-6xl h-full max-h-[800px]">
        <!-- Left: Player List -->
        <div class="glass-panel p-6 rounded-xl flex-1 flex flex-col">
            <h2 class="text-3xl font-bold mb-4">Lobby <span class="text-lg font-normal text-gray-400" id="display-lobby-id"></span></h2>
            <div class="flex gap-2 mb-4">
                <button class="bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded text-sm" onclick="copyLobbyId()">Copy Code</button>
            </div>
            <div class="flex-1 overflow-y-auto mb-4 border border-gray-700 rounded p-2 bg-black/20">
                <div id="player-list" class="flex flex-col gap-1"></div>
            </div>
            <div class="flex gap-4">
                <button id="add-bot-btn" onclick="addBot()" class="bg-gray-600 hover:bg-gray-500 text-white px-4 py-3 rounded flex-1">Add Bot</button>
                <button id="start-btn" onclick="setGameStarted()" class="btn-primary flex-1 text-lg">Start Game</button>
            </div>
            <button onclick="leaveLobby()" class="text-red-500 hover:text-red-400 text-sm underline mt-4 text-center">Leave Lobby</button>
        </div>

        <!-- Right: Settings -->
        <div id="settings-panel" class="glass-panel p-6 rounded-xl w-96 flex flex-col overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-200">Game Settings</h3>
                <button id="reset-btn" onclick="resetDefaults()" class="text-xs text-yellow-500 hover:text-white border border-yellow-500 px-2 py-1 rounded">Reset</button>
            </div>

            <div class="space-y-4 text-sm">
                <!-- Mode -->
                <div>
                    <label class="block text-gray-400 mb-1">Game Mode</label>
                    <select id="set-mode" class="w-full bg-gray-800 border border-gray-600 rounded p-2 text-white">
                        <option value="FFA">Free For All</option>
                        <option value="TEAMS">Team vs Team</option>
                    </select>
                </div>

                <!-- Team Config Section -->
                <div id="team-settings-panel" class="hidden space-y-4 border-t border-b border-gray-700 py-4 my-2">
                    <div class="text-xs font-bold text-gray-400 uppercase">Team Configuration</div>
                    <div>
                        <label class="block text-gray-500">Positioning</label>
                        <select id="set-pos" class="w-full bg-gray-800 border border-gray-600 rounded p-1 text-xs">
                            <option value="together">Together (Side by Side)</option>
                            <option value="checkerboard">Checkerboard (Alternating)</option>
                        </select>
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <input id="set-t1-name" type="text" class="w-full bg-gray-800 border border-gray-600 rounded p-1 text-xs mb-1" placeholder="Team 1">
                            <input id="set-t1-color" type="color" class="w-full h-6 rounded cursor-pointer">
                        </div>
                        <div>
                            <input id="set-t2-name" type="text" class="w-full bg-gray-800 border border-gray-600 rounded p-1 text-xs mb-1" placeholder="Team 2">
                            <input id="set-t2-color" type="color" class="w-full h-6 rounded cursor-pointer">
                        </div>
                    </div>
                </div>

                <!-- Sliders -->
                <div>
                    <div class="flex justify-between"><label class="text-gray-400">Game Speed</label> <span class="text-xs text-yellow-500">Multiplier</span></div>
                    <input id="set-speed" type="number" step="0.1" min="0.5" max="5.0" class="w-full bg-gray-800 border border-gray-600 rounded p-1">
                </div>
                <div>
                    <div class="flex justify-between"><label class="text-gray-400">Unit Cost</label> <span class="text-xs text-yellow-500">Multiplier</span></div>
                    <input id="set-cost" type="number" step="0.1" min="0.1" max="5.0" class="w-full bg-gray-800 border border-gray-600 rounded p-1">
                </div>
                <div>
                    <div class="flex justify-between"><label class="text-gray-400">Gold Reward</label> <span class="text-xs text-yellow-500">Multiplier</span></div>
                    <input id="set-gold" type="number" step="0.1" min="0.1" max="10.0" class="w-full bg-gray-800 border border-gray-600 rounded p-1">
                </div>
                <div>
                    <div class="flex justify-between"><label class="text-gray-400">XP Reward</label> <span class="text-xs text-yellow-500">Multiplier</span></div>
                    <input id="set-xp" type="number" step="0.1" min="0.1" max="10.0" class="w-full bg-gray-800 border border-gray-600 rounded p-1">
                </div>
                <div>
                    <div class="flex justify-between"><label class="text-gray-400">Base HP</label> <span class="text-xs text-yellow-500">Points</span></div>
                    <input id="set-hp" type="number" step="100" min="500" max="20000" class="w-full bg-gray-800 border border-gray-600 rounded p-1">
                </div>
                <div>
                    <div class="flex justify-between"><label class="text-gray-400">XP to Level Up</label> <span class="text-xs text-yellow-500">Multiplier</span></div>
                    <input id="set-levelup" type="number" step="0.1" min="0.1" max="5.0" class="w-full bg-gray-800 border border-gray-600 rounded p-1">
                </div>
            </div>
        </div>
    </div>
</div>

<div id="game-screen" class="screen hidden w-full h-full">
    <canvas id="game-canvas"></canvas>
    <div id="connection-overlay" class="absolute inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center hidden">
        <div class="glass-panel p-8 rounded-xl text-center"><h2 id="connection-msg" class="text-3xl font-bold text-red-500 mb-2">Connection Lost</h2></div>
    </div>
    <div class="game-ui flex flex-col justify-between p-6">
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="glass-panel p-4 rounded flex gap-6 text-base">
                <div class="flex flex-col"><span class="text-yellow-400 font-bold text-lg">GOLD</span><span id="stats-gold" class="text-3xl">0</span></div>
                <div class="flex flex-col border-l border-gray-600 pl-6"><span class="text-blue-400 font-bold text-lg">XP</span><span id="stats-xp" class="text-3xl">0</span></div>
            </div>
            <div id="target-status" class="glass-panel px-6 py-3 rounded font-bold text-red-400 animate-pulse text-xl">Select Target</div>
            <div class="glass-panel p-3 rounded"><button id="upgrade-btn" class="btn-primary text-lg hidden p-4">Evolve</button></div>
        </div>
        <div class="flex flex-col items-center gap-4 pointer-events-auto pb-6">
            <div id="queue-bar" class="flex gap-2 mb-2 hidden"></div>
            <div class="flex items-end gap-6">
                <button id="special-btn" class="relative w-24 h-24 rounded bg-purple-900 border-2 border-purple-500 hover:bg-purple-800 flex flex-col items-center justify-center transition overflow-hidden">Locked</button>
                <div id="unit-bar" class="flex gap-4 glass-panel p-4 rounded-xl"></div>
            </div>
        </div>
    </div>
</div>

</body>
</html>