<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Age of War: FFA Multiplayer</title>
    
    <!-- Firebase Imports -->
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #222; color: white; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; touch-action: none; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #333; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #777; }

        .game-ui { position: absolute; pointer-events: none; width: 100%; height: 100%; top: 0; left: 0; }
        .pointer-events-auto { pointer-events: auto; }
        
        .unit-card { transition: all 0.05s; background: rgba(0,0,0,0.8); border: 2px solid #444; }
        .unit-card:hover { border-color: #fff; transform: translateY(-2px); }
        .unit-card:active { transform: translateY(0); border-color: #eab308; }
        .unit-card.disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }

        .btn-primary { background: #eab308; color: #000; font-weight: bold; padding: 8px 16px; border-radius: 4px; transition: 0.2s; }
        .btn-primary:hover { background: #facc15; }
        .btn-danger { background: #ef4444; color: #fff; font-weight: bold; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
        .btn-danger:hover { background: #dc2626; }
        
        .tooltip { display: none; position: absolute; background: rgba(0,0,0,0.9); border: 1px solid #666; padding: 12px; border-radius: 6px; font-size: 14px; z-index: 100; pointer-events: none; width: 260px; text-align: left; }
        .unit-card:hover .tooltip { display: block; bottom: 110%; left: 50%; transform: translateX(-50%); }

        #lobby-screen { background: url('data:image/svg+xml;utf8,<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g fill="%23333"><path d="M0 0h50v50H0zM50 50h50v50H50z"/></g></svg>'); }
        
        .glass-panel { background: rgba(20, 20, 20, 0.85); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 4px 30px rgba(0,0,0,0.5); }
        
        /* Queue items scaled up */
        .queue-item { width: 45px; height: 45px; border: 1px solid #666; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; font-size: 24px; position: relative; }
        .queue-progress { position: absolute; bottom: 0; left: 0; height: 3px; background: #0f0; transition: width 0.1s linear; }
        
        input[type="color"] { -webkit-appearance: none; border: none; width: 40px; height: 40px; cursor: pointer; background: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid #666; border-radius: 8px; }

        .lobby-list-item { cursor: pointer; transition: background 0.2s; }
        .lobby-list-item:hover { background: rgba(255,255,255,0.1); }
    </style>
</head>
<body>

<!-- === INITIALIZATION & DATA === -->
<script>
    // --- Configuration ---
    const VERSION = "v2.0";
    const STANDARD_SPEED = 1.0; 
    
    const GAME_DATA = {
        ages: [
            {
                name: "Stone Age",
                xpReq: 0,
                baseHp: 5000,
                special: { name: "Meteor Strike", damage: 200, radius: 100, cooldown: 60 },
                units: [
                    { id: 'u1_1', name: "Club Man", icon: "ü™®", cost: 15, delay: 1.0, hp: 55, meleeDmg: 16, rangedDmg: 0, meleeRange: 20, rangedRange: 0 },
                    { id: 'u1_2', name: "Slingshot Man", icon: "üß∂", cost: 25, delay: 1.0, hp: 42, meleeDmg: 10, rangedDmg: 8, meleeRange: 20, rangedRange: 100 },
                    { id: 'u1_3', name: "Dino Rider", icon: "ü¶ñ", cost: 100, delay: 3.0, hp: 160, meleeDmg: 40, rangedDmg: 0, meleeRange: 45, rangedRange: 0 }
                ],
                turret: { id: 't1', name: "Rock Catapult", icon: "ü™µ", cost: 100, damage: 25, range: 200, cooldown: 80 }
            },
            {
                name: "Medieval Age",
                xpReq: 1000,
                baseHp: 5000,
                special: { name: "Arrow Rain", damage: 400, radius: 120, cooldown: 70 },
                units: [
                    { id: 'u2_1', name: "Sword Man", icon: "‚öîÔ∏è", cost: 50, delay: 2.0, hp: 100, meleeDmg: 32, rangedDmg: 0, meleeRange: 20, rangedRange: 0 },
                    { id: 'u2_2', name: "Archer", icon: "üèπ", cost: 75, delay: 1.0, hp: 80, meleeDmg: 20, rangedDmg: 9, meleeRange: 20, rangedRange: 130 },
                    { id: 'u2_3', name: "Knight", icon: "üê¥", cost: 500, delay: 3.0, hp: 300, meleeDmg: 60, rangedDmg: 0, meleeRange: 60, rangedRange: 0 }
                ],
                turret: { id: 't2', name: "Ballista", icon: "üèπ", cost: 400, damage: 50, range: 250, cooldown: 70 }
            },
            {
                name: "Renaissance",
                xpReq: 4000,
                baseHp: 5000,
                special: { name: "Artillery Strike", damage: 800, radius: 150, cooldown: 80 },
                units: [
                    { id: 'u3_1', name: "Duelist", icon: "üó°Ô∏è", cost: 200, delay: 3.0, hp: 200, meleeDmg: 79, rangedDmg: 0, meleeRange: 25, rangedRange: 0 },
                    { id: 'u3_2', name: "Musketeer", icon: "üî´", cost: 400, delay: 3.0, hp: 160, meleeDmg: 40, rangedDmg: 20, meleeRange: 25, rangedRange: 130 },
                    { id: 'u3_3', name: "Cannoneer", icon: "üí£", cost: 1000, delay: 5.0, hp: 600, meleeDmg: 120, rangedDmg: 0, meleeRange: 25, rangedRange: 0 }
                ],
                turret: { id: 't3', name: "Cannon Turret", icon: "üí£", cost: 1000, damage: 120, range: 300, cooldown: 120 }
            },
            {
                name: "Modern Age",
                xpReq: 16000,
                baseHp: 5000,
                special: { name: "Airstrike", damage: 1500, radius: 180, cooldown: 90 },
                units: [
                    { id: 'u4_1', name: "Melee Infantry", icon: "üéñÔ∏è", cost: 1500, delay: 3.0, hp: 300, meleeDmg: 100, rangedDmg: 0, meleeRange: 25, rangedRange: 0 },
                    { id: 'u4_2', name: "Machine Gunner", icon: "üî´", cost: 2000, delay: 3.0, hp: 350, meleeDmg: 60, rangedDmg: 30, meleeRange: 25, rangedRange: 130 }, 
                    { id: 'u4_3', name: "Tank", icon: "üöú", cost: 7000, delay: 8.0, hp: 1200, meleeDmg: 300, rangedDmg: 0, meleeRange: 100, rangedRange: 0 }
                ],
                turret: { id: 't4', name: "Machine Gun", icon: "üî´", cost: 4000, damage: 50, range: 350, cooldown: 10 }
            },
            {
                name: "Future Age",
                xpReq: 60000,
                baseHp: 5000,
                special: { name: "Ion Cannon", damage: 6000, radius: 250, cooldown: 120 },
                units: [
                    { id: 'u5_1', name: "Alien Blade", icon: "üëΩ", cost: 5000, delay: 3.0, hp: 1000, meleeDmg: 250, rangedDmg: 0, meleeRange: 40, rangedRange: 0 },
                    { id: 'u5_2', name: "Alien Blaster", icon: "‚ö°", cost: 6000, delay: 3.0, hp: 800, meleeDmg: 130, rangedDmg: 80, meleeRange: 40, rangedRange: 130 },
                    { id: 'u5_3', name: "War Machine", icon: "üëπ", cost: 20000, delay: 8.0, hp: 3000, meleeDmg: 600, rangedDmg: 0, meleeRange: 100, rangedRange: 0 },
                    { id: 'u5_4', name: "Super Soldier", icon: "ü¶∏", cost: 150000, delay: 3.0, hp: 4000, meleeDmg: 400, rangedDmg: 400, meleeRange: 40, rangedRange: 150 }
                ],
                turret: { id: 't5', name: "Laser Battery", icon: "‚ö°", cost: 15000, damage: 800, range: 450, cooldown: 60 }
            }
        ],
        turretSlots: 2,
        mapRadius: 1000,
        baseRadius: 90, 
        unitCollisionRadius: 20 
    };
    
    // Globals
    let db, auth, user;
    let appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';
    let lobbyId = null;
    let isHost = false;
    let localPlayerId = null;
    let gameLoopRef = null;
    let gameState = null;
    let canvas, ctx;
    let camera = { x: 0, y: 0, zoom: 0.8 };
    let input = { keys: {}, mouse: { x: 0, y: 0, down: false }, targetId: null, mode: 'select' }; 
    let lastUnitBuyTime = 0; 
    let lastUpdateReceived = Date.now(); 
    
    // --- NETWORKING & PREDICTION STATE ---
    let renderState = {
        units: new Map(), // Map<unitId, {x, y, ...targetProps}>
        projectiles: [] // Local sim
    };
    
    // pendingQueue items: { unitId, reqId, timestamp, cost }
    let pendingQueue = []; 
    
    const getLobbyRef = () => db.collection('artifacts').doc(appId).collection('public').doc('data').collection('lobbies');

    async function initApp() {
        // Random Name Gen
        const names = ["Warlord", "Strategist", "Commander", "General", "Captain", "Tactician", "Emperor", "King"];
        const randomName = names[Math.floor(Math.random() * names.length)] + " " + Math.floor(Math.random() * 1000);
        const nameInput = document.getElementById('lobby-name');
        if(nameInput) nameInput.value = randomName;
        
        // Random Color Gen
        const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
        const colorInput = document.getElementById('player-color');
        if(colorInput) colorInput.value = randomColor;

        const firebaseConfig = {
			apiKey: "AIzaSyAcn7ZymxXYPTOhayD1DU2IOAQA7J7Ltrg",
			authDomain: "ageofffa.firebaseapp.com",
			projectId: "ageofffa",
			storageBucket: "ageofffa.firebasestorage.app",
			messagingSenderId: "461491837298",
			appId: "1:461491837298:web:daebae2fb46fe3eb3ee5eb"
		};
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        db = firebase.firestore();
        auth = firebase.auth();

        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            await auth.signInWithCustomToken(__initial_auth_token);
        } else {
            await auth.signInAnonymously();
        }

        auth.onAuthStateChanged(u => {
            user = u;
            if (user) {
                localPlayerId = user.uid;
                document.getElementById('auth-status').innerText = `Connected (${VERSION})`;
                document.getElementById('auth-status').classList.add('text-green-500');
                document.getElementById('version-display').innerText = VERSION;
                showScreen('lobby-screen');
                startLobbyBrowser();
            }
        });
    }
    
    // --- Active Lobby Browser ---
    function startLobbyBrowser() {
        getLobbyRef().onSnapshot(snapshot => {
            const listEl = document.getElementById('active-lobbies-list');
            if(!listEl) return;
            
            listEl.innerHTML = '';
            
            // Filter and sort in memory as per constraints
            const activeLobbies = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                if (data.status === 'waiting' && !data.isPrivate) {
                    activeLobbies.push({ id: doc.id, ...data });
                }
            });
            
            if (activeLobbies.length === 0) {
                listEl.innerHTML = '<div class="text-gray-500 text-sm text-center">No active public games found.</div>';
                return;
            }

            activeLobbies.forEach(lobby => {
                const el = document.createElement('div');
                el.className = 'lobby-list-item bg-gray-800 border border-gray-600 p-2 rounded mb-2 flex justify-between items-center';
                el.innerHTML = `
                    <div>
                        <div class="font-bold text-yellow-500">${lobby.name}</div>
                        <div class="text-xs text-gray-400">Players: ${lobby.players.length}</div>
                    </div>
                    <button class="bg-blue-600 text-xs px-2 py-1 rounded">Join</button>
                `;
                el.onclick = () => {
                    document.getElementById('lobby-id-input').value = lobby.id;
                    joinLobby();
                };
                listEl.appendChild(el);
            });
        });
    }

    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    }

    // --- Lobby Logic ---
    async function createLobby() {
        const lobbyNameVal = document.getElementById('lobby-name').value || "New Game";
        const playerNameVal = document.getElementById('lobby-name').value || "Player 1";
        const colorVal = document.getElementById('player-color').value || "#ff0000";
        const isPrivate = document.getElementById('is-private-lobby').checked;
        
        // Generate Short Code
        const shortCode = Math.random().toString(36).substring(2, 8).toUpperCase();
        
        const lobbyRef = getLobbyRef().doc(shortCode);
        lobbyId = shortCode;
        
        const initialPlayer = createPlayerObj(localPlayerId, playerNameVal, false, colorVal);
        
        await lobbyRef.set({
            hostId: localPlayerId,
            name: lobbyNameVal,
            status: 'waiting',
            isPrivate: isPrivate,
            players: [initialPlayer],
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            lastHeartbeat: firebase.firestore.FieldValue.serverTimestamp(),
            stateJSON: JSON.stringify({ units: [], projectiles: [], effects: [] }),
            actions: []
        });

        enterLobbyUI(lobbyId, true);
    }

    async function joinLobby() {
        let id = document.getElementById('lobby-id-input').value.trim();
        const playerNameVal = document.getElementById('lobby-name').value || "Player";
        const colorVal = document.getElementById('player-color').value || "#00ff00";

        if(!id) return alert("Enter Lobby ID");

        // Only auto-uppercase if it looks like a short code (<= 8 chars).
        // This allows joining legacy lobbies that have long, case-sensitive IDs.
        if (id.length <= 8) {
            id = id.toUpperCase();
        }
        
        const lobbyRef = getLobbyRef().doc(id);
        const doc = await lobbyRef.get();
        
        if(!doc.exists) return alert("Lobby not found");
        if(doc.data().status !== 'waiting') return alert("Game already started");

        const newPlayer = createPlayerObj(localPlayerId, playerNameVal, false, colorVal);
        
        await db.runTransaction(async (t) => {
            const fresh = await t.get(lobbyRef);
            if (!fresh.exists) throw "Lobby gone";
            const players = fresh.data().players;
            if (players.find(p => p.id === localPlayerId)) return; 
            if (players.length >= 10) throw "Lobby Full";
            players.push(newPlayer);
            t.update(lobbyRef, { players: players });
        });

        lobbyId = id;
        enterLobbyUI(lobbyId, false);
    }

    function createPlayerObj(id, name, isBot, color) {
        return {
            id: id,
            name: name,
            isBot: isBot,
            age: 0,
            xp: 0,
            gold: 300,
            hp: GAME_DATA.ages[0].baseHp,
            maxHp: GAME_DATA.ages[0].baseHp,
            turrets: [], 
            targetId: null, 
            color: color || `hsl(${Math.random() * 360}, 70%, 50%)`,
            spawnQueue: [], 
            spawnTimer: 0, 
            specialCooldown: 0
        };
    }
    
    async function kickPlayer(targetId) {
        if (!isHost || !lobbyId) return;
        const lobbyRef = getLobbyRef().doc(lobbyId);
        
        await db.runTransaction(async (t) => {
             const doc = await t.get(lobbyRef);
             if (!doc.exists) return;
             const data = doc.data();
             const newPlayers = data.players.filter(p => p.id !== targetId);
             t.update(lobbyRef, { players: newPlayers });
        });
    }

    async function leaveLobby() {
        if (!lobbyId) return;
        const lobbyRef = getLobbyRef().doc(lobbyId);
        
        if (lobbyUnsub) lobbyUnsub();
        lobbyUnsub = null;
        
        await db.runTransaction(async (t) => {
             const doc = await t.get(lobbyRef);
             if (!doc.exists) return;
             const data = doc.data();
             
             // Remove self
             const newPlayers = data.players.filter(p => p.id !== localPlayerId);
             
             if (newPlayers.length === 0) {
                 // Delete if empty
                 t.delete(lobbyRef);
             } else {
                 let updates = { players: newPlayers };
                 // Pass Host if host left
                 if (data.hostId === localPlayerId) {
                     updates.hostId = newPlayers[0].id; // Give to next player
                 }
                 t.update(lobbyRef, updates);
             }
        });
        
        location.reload();
    }

    function enterLobbyUI(id, host) {
        isHost = host;
        showScreen('waiting-room');
        document.getElementById('display-lobby-id').innerText = id;
        if(!host) document.getElementById('start-btn').classList.add('hidden');
        if(!host) document.getElementById('add-bot-btn').classList.add('hidden');
        
        const leaveBtn = document.getElementById('leave-btn');
        if (host) {
            document.getElementById('leave-msg').innerText = "Leaving will pass Host to next player.";
        } else {
            document.getElementById('leave-msg').innerText = "";
        }

        lobbyUnsub = getLobbyRef().doc(id).onSnapshot(doc => {
            if(!doc.exists) {
                // Lobby deleted
                alert("Lobby has been closed.");
                location.reload();
                return;
            }
            const data = doc.data();
            
            // Check if kicked
            const amIIn = data.players.find(p => p.id === localPlayerId);
            if (!amIIn) {
                alert("You have been kicked from the lobby.");
                location.reload();
                return;
            }

            // Update Host status (in case host migrated)
            isHost = (data.hostId === localPlayerId);
            if(isHost) {
                document.getElementById('start-btn').classList.remove('hidden');
                document.getElementById('add-bot-btn').classList.remove('hidden');
                document.getElementById('leave-msg').innerText = "Leaving will pass Host to next player.";
            } else {
                document.getElementById('start-btn').classList.add('hidden');
                document.getElementById('add-bot-btn').classList.add('hidden');
                document.getElementById('leave-msg').innerText = "";
            }

            const list = document.getElementById('player-list');
            list.innerHTML = data.players.map(p => {
                let kickBtn = '';
                if (isHost && p.id !== localPlayerId) {
                    kickBtn = `<button onclick="kickPlayer('${p.id}')" class="btn-danger ml-2">X</button>`;
                }
                
                return `
                <div class="flex items-center justify-between bg-gray-700 p-2 rounded mb-1">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full" style="background:${p.color}"></div>
                        <span>${p.name} ${p.isBot ? '(BOT)' : ''}</span>
                    </div>
                    <div class="flex items-center">
                        ${p.id === data.hostId ? '<span class="text-xs text-yellow-500 mr-2">HOST</span>' : ''}
                        ${p.id === localPlayerId ? '<span class="text-xs bg-blue-600 px-1 rounded">YOU</span>' : ''}
                        ${kickBtn}
                    </div>
                </div>`;
            }).join('');

            if(data.status === 'playing' || data.status === 'paused') {
                startGame(data);
            } else if (data.status === 'finished') {
                if (gameState !== 'finished') {
                    gameState = 'finished';
                    const amIWinner = data.winner?.id === localPlayerId;
                    const resultText = amIWinner ? "VICTORY!" : "DEFEAT";
                    const resultColor = amIWinner ? "text-yellow-400" : "text-red-500";
                    
                    const overlay = document.createElement('div');
                    overlay.className = "absolute inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center z-50 pointer-events-auto";
                    overlay.innerHTML = `
                        <h1 class="text-6xl font-bold ${resultColor} mb-4">${resultText}</h1>
                        <p class="text-2xl text-white mb-8">Winner: ${data.winner?.name || 'Unknown'}</p>
                        <button onclick="location.reload()" class="btn-primary">Back to Menu</button>
                    `;
                    document.body.appendChild(overlay);
                }
            }
        });
    }

    function copyLobbyId() {
        const idText = document.getElementById('display-lobby-id').innerText;
        const tempInput = document.createElement('input');
        tempInput.value = idText;
        document.body.appendChild(tempInput);
        tempInput.select();
        document.execCommand('copy');
        document.body.removeChild(tempInput);
        const btn = document.getElementById('copy-box');
        const originalBg = btn.style.background;
        btn.style.background = '#225522';
        setTimeout(() => { btn.style.background = originalBg; }, 200);
    }

    async function addBot() {
        if(!isHost) return;
        const lobbyRef = getLobbyRef().doc(lobbyId);
        const doc = await lobbyRef.get();
        const players = doc.data().players;
        if(players.length >= 10) return alert("Lobby full");
        
        const bot = createPlayerObj('bot_' + Date.now(), "Bot " + Math.floor(Math.random()*100), true, `hsl(${Math.random() * 360}, 70%, 50%)`);
        players.push(bot);
        await lobbyRef.update({ players });
    }

    async function setGameStarted() {
        if(!isHost) return;
        await getLobbyRef().doc(lobbyId).update({ status: 'playing' });
    }

    // --- Game Logic ---

    let simState = {
        players: [],
        units: [], 
        projectiles: [], 
        effects: [] 
    };
    
    function startGame(initialData) {
        if(lobbyUnsub) lobbyUnsub();
        showScreen('game-screen');
        
        canvas = document.getElementById('game-canvas');
        ctx = canvas.getContext('2d');
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        simState.players = initialData.players;
        
        const radius = GAME_DATA.mapRadius * 0.8;
        const center = { x: 0, y: 0 };
        const angleStep = (Math.PI * 2) / simState.players.length;
        
        simState.players.forEach((p, i) => {
            const angle = angleStep * i;
            p.x = center.x + Math.cos(angle) * radius;
            p.y = center.y + Math.sin(angle) * radius;
            const ageData = GAME_DATA.ages[p.age];
            if(ageData && ageData.turret) {
                 p.turrets = [{ id: 'base_turret', typeId: ageData.turret.id, cooldown: 0, slot: 0 }];
            }
        });

        // Input Listeners
        let isDragging = false;
        let lastPos = { x: 0, y: 0 };
        const getPos = (e) => {
            if (e.changedTouches) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        };
        const onDown = (e) => {
            isDragging = false;
            const p = getPos(e);
            input.mouse.down = true;
            input.mouse.x = p.x;
            input.mouse.y = p.y;
            lastPos = p;
        };
        const onMove = (e) => {
            e.preventDefault(); 
            const p = getPos(e);
            input.mouse.x = p.x;
            input.mouse.y = p.y;
            if (input.mouse.down) {
                const dx = p.x - lastPos.x;
                const dy = p.y - lastPos.y;
                if (Math.abs(dx) > 2 || Math.abs(dy) > 2) isDragging = true;
                if (isDragging) {
                    camera.x -= dx / camera.zoom;
                    camera.y -= dy / camera.zoom;
                    lastPos = p;
                }
            }
        };
        const onUp = (e) => {
            input.mouse.down = false;
            if (!isDragging) handleInput();
            isDragging = false;
        };
        canvas.addEventListener('mousedown', onDown);
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseup', onUp);
        canvas.addEventListener('touchstart', onDown, {passive: false});
        canvas.addEventListener('touchmove', onMove, {passive: false});
        canvas.addEventListener('touchend', onUp);
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            camera.zoom *= (1 - e.deltaY * 0.001);
            camera.zoom = Math.max(0.2, Math.min(camera.zoom, 2.5));
        });
        window.addEventListener('contextmenu', e => {
            e.preventDefault();
            if (input.mode === 'ability') {
                input.mode = 'select';
                document.body.style.cursor = 'default';
            }
        });

        const me = simState.players.find(p => p.id === localPlayerId);
        if (me) {
            camera.x = me.x;
            camera.y = me.y;
        }

        if(isHost) {
            // HOST LOGIC
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    getLobbyRef().doc(lobbyId).update({ status: 'paused' });
                } else {
                    getLobbyRef().doc(lobbyId).update({ status: 'playing' });
                }
            });

            requestAnimationFrame(hostGameLoop);
            setInterval(hostSync, 200); 
        } else {
            // CLIENT LISTENER
            getLobbyRef().doc(lobbyId).onSnapshot(doc => {
                if(!doc.exists) return;
                const d = doc.data();
                lastUpdateReceived = Date.now();
                
                const connectionOverlay = document.getElementById('connection-overlay');
                const connectionMsg = document.getElementById('connection-msg');
                
                if (d.status === 'paused') {
                    connectionOverlay.classList.remove('hidden');
                    connectionMsg.innerText = "Host Paused the Game (Minimized)";
                } else {
                    connectionOverlay.classList.add('hidden');
                }

                if(d.stateJSON) {
                    const parsed = JSON.parse(d.stateJSON);
                    
                    simState.players = d.players;
                    
                    const me = simState.players.find(p => p.id === localPlayerId);
                    if(me) {
                        // RECONCILE PENDING QUEUE
                        if(me.spawnQueue) {
                            const serverQueueIds = new Set(me.spawnQueue.map(i => i.reqId));
                            pendingQueue = pendingQueue.filter(pending => !serverQueueIds.has(pending.reqId));
                        }
                    }
                    
                    simState.projectiles = parsed.projectiles;
                    simState.effects = parsed.effects;
                    
                    // --- INTERPOLATION SETUP ---
                    parsed.units.forEach(serverUnit => {
                        if (renderState.units.has(serverUnit.id)) {
                            const u = renderState.units.get(serverUnit.id);
                            u.targetX = serverUnit.x;
                            u.targetY = serverUnit.y;
                            u.hp = serverUnit.hp;
                            u.maxHp = serverUnit.maxHp;
                        } else {
                            renderState.units.set(serverUnit.id, {
                                ...serverUnit,
                                x: serverUnit.x,
                                y: serverUnit.y,
                                targetX: serverUnit.x,
                                targetY: serverUnit.y
                            });
                        }
                    });

                    const serverIds = new Set(parsed.units.map(u => u.id));
                    for (let [id, u] of renderState.units) {
                        if (!serverIds.has(id)) renderState.units.delete(id);
                    }
                    
                    simState.units = Array.from(renderState.units.values());
                }
            });
            requestAnimationFrame(clientRenderLoop);
        }

        updateUI();
    }

    // --- Host Simulation ---
    
    const TICK_RATE = 1 / 30; 
    let lastTime = performance.now();
    let accumulator = 0;
    let syncTimer = 0;

    function hostGameLoop(time) {
        if (gameState === 'finished') return;
        
        if (document.hidden) {
            lastTime = time;
            requestAnimationFrame(hostGameLoop);
            return;
        }

        let deltaTime = (time - lastTime) / 1000;
        lastTime = time;

        if (deltaTime > 0.25) deltaTime = 0.25;

        accumulator += deltaTime;

        while (accumulator >= TICK_RATE) {
            updateHostLogic(TICK_RATE);
            accumulator -= TICK_RATE;
        }
        
        syncTimer += deltaTime;
        if (syncTimer > 0.1) {
            hostSyncState();
            syncTimer = 0;
        }

        renderGame(0);
        updateUI();

        requestAnimationFrame(hostGameLoop);
    }

    function updateHostLogic(dt) {
        getLobbyRef().doc(lobbyId).collection('requests').get().then(snap => {
            snap.forEach(doc => {
                const req = doc.data();
                processAction(req);
                doc.ref.delete();
            });
        });

        simState.players.forEach(p => {
            if (p.hp <= 0) {
                p.spawnQueue = [];
                return;
            }

            if (p.isBot) runBotLogic(p, dt);
            
            if (p.specialCooldown > 0) p.specialCooldown -= dt;

            if (p.spawnQueue.length > 0) {
                p.spawnTimer -= dt;
                if (p.spawnTimer <= 0) {
                    const item = p.spawnQueue.shift();
                    spawnUnitReal(p.id, item.unitId);
                    
                    if (p.spawnQueue.length > 0) {
                        const nextItem = p.spawnQueue[0];
                        const stats = getUnitStats(p.age, nextItem.unitId);
                        p.spawnTimer = stats ? stats.delay : 1.0;
                    } else {
                        p.spawnTimer = 0;
                    }
                }
            }
        });

        simState.units = simState.units.filter(u => u.hp > 0);
        simState.units.forEach(u => updateUnit(u, dt));

        simState.players.forEach(p => {
            if (p.hp > 0) updateTurrets(p, dt);
        });

        simState.projectiles = simState.projectiles.filter(p => {
            p.x += p.vx * dt * 400; 
            p.y += p.vy * dt * 400;
            
            let hit = false;
            const targets = simState.units.filter(u => u.ownerId !== p.ownerId);
            for (let t of targets) {
                if (dist(p.x, p.y, t.x, t.y) < GAME_DATA.unitCollisionRadius + 5) {
                    t.hp -= p.damage;
                    hit = true;
                    simState.effects.push({x: t.x, y: t.y, type: 'hit', timer: 0.5});
                    if (t.hp <= 0) awardKill(p.ownerId, t);
                    break;
                }
            }
            
            if (!hit) {
                simState.players.forEach(pl => {
                    if (pl.id !== p.ownerId && pl.hp > 0 && dist(p.x, p.y, pl.x, pl.y) < GAME_DATA.baseRadius) {
                        pl.hp -= p.damage;
                        hit = true;
                        if (pl.hp <= 0) pl.hp = 0; 
                    }
                });
            }

            return !hit && Math.abs(p.x) < 2000 && Math.abs(p.y) < 2000; 
        });

        simState.effects = simState.effects.filter(e => {
            e.timer -= dt;
            return e.timer > 0;
        });
        
        const alivePlayers = simState.players.filter(p => p.hp > 0);
        if (alivePlayers.length === 1 && simState.players.length > 1) {
            const winner = alivePlayers[0];
            gameState = 'finished';
            try {
                getLobbyRef().doc(lobbyId).update({
                    status: 'finished',
                    winner: { id: winner.id, name: winner.name }
                });
            } catch(e) { console.error("Win update error", e); }
        }
    }

    function hostSyncState() {
        if(gameState === 'finished') return;
        const stateJSON = JSON.stringify({
            units: simState.units.map(u => ({
                id: u.id, ownerId: u.ownerId, typeId: u.typeId, 
                x: Math.round(u.x), y: Math.round(u.y), 
                hp: u.hp, maxHp: u.maxHp, icon: u.icon
            })),
            projectiles: simState.projectiles,
            effects: simState.effects
        });
        getLobbyRef().doc(lobbyId).update({ 
            stateJSON: stateJSON,
            lastHeartbeat: firebase.firestore.FieldValue.serverTimestamp()
        });
    }

    function hostSync() {
        if(gameState === 'finished') return;
        getLobbyRef().doc(lobbyId).update({
            players: simState.players
        });
    }

    // --- Simulation Helpers ---

    function getUnitStats(ageIdx, unitId) {
        for (const age of GAME_DATA.ages) {
            const u = age.units.find(x => x.id === unitId);
            if (u) return u;
        }
        return null;
    }

    function runBotLogic(bot, dt) {
        if (!bot.targetId || Math.random() < 0.01) {
            const enemies = simState.players.filter(p => p.id !== bot.id && p.hp > 0);
            if (enemies.length > 0) {
                bot.targetId = enemies[Math.floor(Math.random() * enemies.length)].id;
            }
        }
        const nextAge = GAME_DATA.ages[bot.age + 1];
        if (nextAge && bot.xp >= nextAge.xpReq) {
             bot.age++;
             bot.hp = Math.min(bot.hp + 500, GAME_DATA.ages[bot.age].baseHp);
             bot.maxHp = GAME_DATA.ages[bot.age].baseHp;
             bot.turrets = [{ id: 'base_turret', typeId: GAME_DATA.ages[bot.age].turret.id, cooldown: 0, slot: 0 }];
        }
        const ageData = GAME_DATA.ages[bot.age];
        if (bot.spawnQueue.length < 3 && Math.random() < 0.05) {
            const unitOpts = ageData.units;
            const pick = unitOpts[Math.floor(Math.random() * unitOpts.length)];
            if (bot.gold >= pick.cost) {
                bot.gold -= pick.cost;
                bot.spawnQueue.push({ reqId: 'bot_'+Math.random(), unitId: pick.id });
                if (bot.spawnQueue.length === 1) bot.spawnTimer = pick.delay;
            }
        }
        if (bot.specialCooldown <= 0 && ageData.special && bot.targetId) {
             const t = simState.players.find(p => p.id === bot.targetId);
             if (t) {
                 useSpecial(bot.id, t.x, t.y);
             }
        }
    }

    function updateUnit(u, dt) {
        const owner = simState.players.find(p => p.id === u.ownerId);
        const targetPlayer = simState.players.find(p => p.id === u.targetId);
        const unitRadius = GAME_DATA.unitCollisionRadius;
        
        if(u.cooldownTimer > 0) u.cooldownTimer -= dt * 60;

        if (!targetPlayer || targetPlayer.hp <= 0) {
            let close = null;
            let minDist = Infinity;
            simState.players.forEach(p => {
                if (p.id !== u.ownerId && p.hp > 0) {
                    const d = dist(u.x, u.y, p.x, p.y);
                    if (d < minDist) { minDist = d; close = p; }
                }
            });
            if (close) {
                u.targetId = close.id; 
            }
            return;
        }

        let enemy = null;
        let enemyDist = Infinity;
        
        for (let other of simState.units) {
            if (other.ownerId !== u.ownerId) {
                const d = dist(u.x, u.y, other.x, other.y);
                const combinedRadii = unitRadius * 2;
                const maxRange = Math.max(u.meleeRange, u.rangedRange);
                
                if (d <= maxRange + combinedRadii && d < enemyDist) {
                    enemyDist = d;
                    enemy = other;
                }
            }
        }
        
        if (!enemy) {
             const d = dist(u.x, u.y, targetPlayer.x, targetPlayer.y);
             const baseRadius = GAME_DATA.baseRadius;
             const maxRange = Math.max(u.meleeRange, u.rangedRange);
             
             if (d <= maxRange + unitRadius + baseRadius) {
                 enemy = { type: 'base', x: targetPlayer.x, y: targetPlayer.y, id: targetPlayer.id, radius: baseRadius };
                 enemyDist = d;
             }
        }

        if (enemy) {
            const enemyRadius = enemy.type === 'base' ? GAME_DATA.baseRadius : unitRadius;
            const isMeleeRange = enemyDist <= u.meleeRange + unitRadius + enemyRadius;
            const isRangedRange = u.rangedDmg > 0 && enemyDist <= u.rangedRange + unitRadius + enemyRadius;

            if (u.cooldownTimer <= 0) {
                if (isMeleeRange && u.meleeDmg > 0) {
                    if (enemy.type === 'base') {
                        const p = simState.players.find(pl => pl.id === enemy.id);
                        if(p) p.hp -= u.meleeDmg;
                    } else {
                        enemy.hp -= u.meleeDmg;
                        if(enemy.hp <= 0) awardKill(u.ownerId, enemy);
                    }
                    simState.effects.push({x: enemy.x, y: enemy.y, type: 'hit', timer: 0.2});
                    u.cooldownTimer = 60; 
                } else if (isRangedRange) {
                    simState.projectiles.push({
                        x: u.x, y: u.y, 
                        vx: (enemy.x - u.x) / dist(u.x, u.y, enemy.x, enemy.y),
                        vy: (enemy.y - u.y) / dist(u.x, u.y, enemy.x, enemy.y),
                        damage: u.rangedDmg,
                        ownerId: u.ownerId
                    });
                    u.cooldownTimer = 60;
                } else {
                    moveUnit(u, targetPlayer, dt);
                }
            }
        } else {
            moveUnit(u, targetPlayer, dt);
        }
    }

    function moveUnit(u, targetPlayer, dt) {
        let canMove = true;
        const step = STANDARD_SPEED * dt * 50; 
        const angle = Math.atan2(targetPlayer.y - u.y, targetPlayer.x - u.x);
        const nextX = u.x + Math.cos(angle) * step;
        const nextY = u.y + Math.sin(angle) * step;

        for (let other of simState.units) {
            if (other.id !== u.id) {
                const d = dist(nextX, nextY, other.x, other.y);
                if (d < GAME_DATA.unitCollisionRadius * 2) {
                    const dx = other.x - u.x;
                    const dy = other.y - u.y;
                    const dot = dx * Math.cos(angle) + dy * Math.sin(angle);
                    if (dot > 0) {
                        canMove = false;
                        break;
                    }
                }
            }
        }

        if (canMove) {
            u.x = nextX;
            u.y = nextY;
        }
    }

    function updateTurrets(p, dt) {
        p.turrets.forEach(t => {
            const tData = getTurretData(t.typeId);
            if (!tData) return;
            
            if (t.cooldown > 0) t.cooldown -= dt * 60;
            
            if (t.cooldown <= 0) {
                let target = null;
                let minD = tData.range;
                for (let u of simState.units) {
                    if (u.ownerId !== p.id) {
                        const d = dist(p.x, p.y, u.x, u.y);
                        if (d < minD) { minD = d; target = u; }
                    }
                }
                
                if (target) {
                    simState.projectiles.push({
                        x: p.x, y: p.y,
                        vx: (target.x - p.x) / dist(p.x, p.y, target.x, target.y),
                        vy: (target.y - p.y) / dist(p.x, p.y, target.x, target.y),
                        damage: tData.damage,
                        ownerId: p.id
                    });
                    t.cooldown = tData.cooldown;
                }
            }
        });
    }

    function spawnUnitReal(playerId, unitId) {
        const p = simState.players.find(x => x.id === playerId);
        const stats = getUnitStats(p.age, unitId);
        
        let spawnX = p.x;
        let spawnY = p.y;
        
        if (p.targetId) {
            const target = simState.players.find(tp => tp.id === p.targetId);
            if (target) {
                const a = Math.atan2(target.y - p.y, target.x - p.x);
                spawnX += Math.cos(a) * (GAME_DATA.baseRadius + 20);
                spawnY += Math.sin(a) * (GAME_DATA.baseRadius + 20);
            }
        } else {
             const a = Math.atan2(-p.y, -p.x);
             spawnX += Math.cos(a) * (GAME_DATA.baseRadius + 20);
             spawnY += Math.sin(a) * (GAME_DATA.baseRadius + 20);
        }

        simState.units.push({
            id: Math.random().toString(36),
            ownerId: p.id,
            typeId: unitId,
            x: spawnX,
            y: spawnY,
            hp: stats.hp,
            maxHp: stats.hp,
            meleeDmg: stats.meleeDmg,
            rangedDmg: stats.rangedDmg,
            meleeRange: stats.meleeRange,
            rangedRange: stats.rangedRange,
            cooldownTimer: 0,
            targetId: p.targetId,
            icon: stats.icon,
            cost: stats.cost
        });
    }

    function useSpecial(playerId, x, y) {
        const p = simState.players.find(x => x.id === playerId);
        const age = GAME_DATA.ages[p.age];
        if(!age.special) return;
        
        if (p.specialCooldown > 0) return;

        p.specialCooldown = age.special.cooldown;
        
        simState.effects.push({x, y, type: 'explosion', radius: age.special.radius, timer: 1.0});
        
        simState.units.forEach(u => {
            if (u.ownerId !== playerId && dist(u.x, u.y, x, y) < age.special.radius) {
                u.hp -= age.special.damage;
                if(u.hp <= 0) awardKill(playerId, u);
            }
        });
    }

    function awardKill(killerId, victimUnit) {
        const killer = simState.players.find(p => p.id === killerId);
        if (killer && victimUnit.cost) {
            killer.gold += Math.ceil(victimUnit.cost * 1.3);
            killer.xp += Math.floor(victimUnit.cost * 1.0);
        }
    }

    function processAction(action) {
        if (action.type === 'queueUnit') {
            const p = simState.players.find(x => x.id === action.playerId);
            if (p && p.hp > 0) {
                 const stats = getUnitStats(p.age, action.unitId);
                 if (stats && p.gold >= stats.cost) {
                     p.gold -= stats.cost;
                     p.spawnQueue.push({ unitId: action.unitId, reqId: action.reqId });
                     if (p.spawnQueue.length === 1) {
                         p.spawnTimer = stats.delay;
                     }
                 }
            }
        } else if (action.type === 'setTarget') {
            const p = simState.players.find(x => x.id === action.playerId);
            if (p) p.targetId = action.targetId;
        } else if (action.type === 'upgrade') {
            const p = simState.players.find(x => x.id === action.playerId);
            if (p) {
                const nextAge = GAME_DATA.ages[p.age + 1];
                if (nextAge && p.xp >= nextAge.xpReq) {
                    p.age++;
                    p.hp += 500;
                    p.maxHp = GAME_DATA.ages[p.age].baseHp;
                    p.turrets = [{ id: 'base_turret', typeId: GAME_DATA.ages[p.age].turret.id, cooldown: 0, slot: 0 }];
                }
            }
        } else if (action.type === 'special') {
             useSpecial(action.playerId, action.x, action.y);
        }
    }

    // --- Client Interaction ---
    
    let lastClientTime = performance.now();
    
    function clientRenderLoop(time) {
        const dt = (time - lastClientTime) / 1000;
        lastClientTime = time;
        
        const timeSinceUpdate = Date.now() - lastUpdateReceived;
        const connectionOverlay = document.getElementById('connection-overlay');
        const connectionMsg = document.getElementById('connection-msg');
        
        if (timeSinceUpdate > 4000 && !document.hidden && connectionOverlay.classList.contains('hidden')) {
             connectionOverlay.classList.remove('hidden');
             connectionMsg.innerText = "Connection Lost / Host Left";
        }

        // --- FIXED PROGRESS BAR LOGIC (CLIENT SIDE) ---
        const p = simState.players.find(p => p.id === localPlayerId);
        if (p) {
            // Count total items in queue (server + pending)
            const combinedQueueLength = (p.spawnQueue ? p.spawnQueue.length : 0) + pendingQueue.length;
            
            // Detect queue state changes
            if (p._lastQueueLen !== combinedQueueLength) {
                // If queue grew from empty, or shrank (unit spawned), reset/adjust timer
                if (combinedQueueLength > 0 && (p._lastQueueLen === 0 || combinedQueueLength < p._lastQueueLen)) {
                    // Get unit ID at head of queue
                    let headUnitId = null;
                    if (p.spawnQueue && p.spawnQueue.length > 0) headUnitId = p.spawnQueue[0].unitId;
                    else if (pendingQueue.length > 0) headUnitId = pendingQueue[0].unitId;
                    
                    if (headUnitId) {
                         const stats = getUnitStats(p.age, headUnitId);
                         if (stats) p._clientTimer = stats.delay;
                    }
                }
                p._lastQueueLen = combinedQueueLength;
            }

            // Run timer
            if (combinedQueueLength > 0 && p._clientTimer > 0) {
                p._clientTimer -= dt;
                if (p._clientTimer < 0) p._clientTimer = 0;
            } else if (combinedQueueLength === 0) {
                p._clientTimer = 0;
            }
        }

        renderGame(dt);
        updateUI();
        if (gameState !== 'finished') requestAnimationFrame(clientRenderLoop);
    }

    function sendAction(data) {
        const now = Date.now();
        const reqId = localPlayerId + '_' + now + '_' + Math.random();

        if (data.type === 'queueUnit') {
            lastUnitBuyTime = now;

            if (!isHost) {
                const p = simState.players.find(x => x.id === localPlayerId);
                const stats = getUnitStats(p.age, data.unitId);
                if (p && stats && p.gold >= stats.cost) {
                    const wasQueueEmpty = (!p.spawnQueue || p.spawnQueue.length === 0) && pendingQueue.length === 0;
                    pendingQueue.push({ unitId: data.unitId, reqId: reqId, timestamp: now, cost: stats.cost });
                    
                    // Initialize timer immediately if starting new queue
                    if (wasQueueEmpty) {
                        p._clientTimer = stats.delay;
                    }
                    updateUI();
                }
            }
        }

        const payload = { ...data, playerId: localPlayerId, reqId: reqId };

        if (isHost) {
            processAction(payload);
        } else {
            getLobbyRef().doc(lobbyId).collection('requests').add({
                ...payload,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
        }
    }

    function handleInput() {
        const rect = canvas.getBoundingClientRect();
        const mx = (input.mouse.x - rect.left - canvas.width/2) / camera.zoom + camera.x;
        const my = (input.mouse.y - rect.top - canvas.height/2) / camera.zoom + camera.y;

        if (input.mode === 'ability') {
            sendAction({ type: 'special', x: mx, y: my });
            input.mode = 'select';
            document.body.style.cursor = 'default';
            return;
        }

        let clickedBase = null;
        simState.players.forEach(p => {
            if (dist(mx, my, p.x, p.y) < GAME_DATA.baseRadius) {
                clickedBase = p;
            }
        });

        if (clickedBase && clickedBase.id !== localPlayerId) {
            sendAction({ type: 'setTarget', targetId: clickedBase.id });
        }
    }

    // --- Rendering ---

    function renderGame(dt) {
        if (!dt || dt > 0.5) dt = 0.016;

        ctx.fillStyle = '#1a1a1a'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.beginPath();
        
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x, -camera.y);

        ctx.strokeStyle = '#444';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(0, 0, GAME_DATA.mapRadius, 0, Math.PI * 2);
        ctx.stroke();

        simState.players.forEach(p => {
            if (p.hp <= 0) {
                 ctx.fillStyle = '#222';
                 ctx.beginPath(); ctx.arc(p.x, p.y, GAME_DATA.baseRadius, 0, Math.PI*2); ctx.fill();
                 return;
            }
            
            const me = simState.players.find(me => me.id === localPlayerId);
            if (me && me.targetId === p.id) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 4;
                ctx.beginPath(); ctx.arc(p.x, p.y, GAME_DATA.baseRadius + 10, 0, Math.PI*2); ctx.stroke();
            }

            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, GAME_DATA.baseRadius, 0, Math.PI*2);
            ctx.fill();
            
            if(p.turrets.length > 0) {
                const tur = p.turrets[0];
                const tData = getTurretData(tur.typeId);
                ctx.fillStyle = '#555';
                ctx.beginPath(); ctx.arc(p.x, p.y, 30, 0, Math.PI*2); ctx.fill(); 
                ctx.fillStyle = '#fff';
                ctx.font = '36px Arial'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(tData.icon, p.x, p.y);
            }

            drawBar(p.x, p.y - GAME_DATA.baseRadius - 15, 120, 12, p.hp, p.maxHp, '#0f0');
            
            ctx.fillStyle = '#fff';
            ctx.font = '22px Arial';
            ctx.fillText(p.name, p.x, p.y - GAME_DATA.baseRadius - 40);
        });

        const unitsToDraw = isHost ? simState.units : Array.from(renderState.units.values());
        
        unitsToDraw.forEach(u => {
            if (!isHost) {
                const t = 1.0 - Math.pow(0.001, dt); 
                u.x += (u.targetX - u.x) * t;
                u.y += (u.targetY - u.y) * t;
                
                if (dist(u.x, u.y, u.targetX, u.targetY) > 60) {
                    u.x = u.targetX;
                    u.y = u.targetY;
                }
            }

            const p = simState.players.find(pl => pl.id === u.ownerId);
            const color = p ? p.color : '#fff';
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(u.x, u.y, 28, 0, Math.PI*2);
            ctx.fill();
            
            ctx.font = '44px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(u.icon, u.x, u.y);

            drawBar(u.x, u.y - 48, 48, 8, u.hp, u.maxHp, '#0f0');
        });

        simState.projectiles.forEach(p => {
            if (!isHost) {
                p.x += p.vx * dt * 400; 
                p.y += p.vy * dt * 400;
            }

            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 8, 0, Math.PI*2); 
            ctx.fill();
        });
        
        simState.effects.forEach(e => {
            if (e.type === 'hit') {
                ctx.fillStyle = `rgba(255, 255, 255, ${e.timer * 2})`;
                ctx.beginPath(); ctx.arc(e.x, e.y, 20, 0, Math.PI*2); ctx.fill(); 
            } else if (e.type === 'explosion') {
                ctx.fillStyle = `rgba(255, 100, 0, ${e.timer})`;
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill();
            }
        });

        if (input.mode === 'ability') {
            const me = simState.players.find(x => x.id === localPlayerId);
            const age = GAME_DATA.ages[me.age];
            if(age && age.special) {
                const rect = canvas.getBoundingClientRect();
                const wx = (input.mouse.x - canvas.width/2) / camera.zoom + camera.x;
                const wy = (input.mouse.y - canvas.height/2) / camera.zoom + camera.y;

                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(wx, wy, age.special.radius, 0, Math.PI*2);
                ctx.stroke();
                ctx.fill();
            }
        }

        ctx.restore();
    }

    function drawBar(x, y, w, h, val, max, color) {
        ctx.fillStyle = '#000';
        ctx.fillRect(x - w/2, y, w, h);
        ctx.fillStyle = color;
        const fill = Math.max(0, (val / max) * w);
        ctx.fillRect(x - w/2, y, fill, h);
    }

    // --- UI Updates ---
    
    let currentRenderedAge = -1;

    function updateUI() {
        const p = simState.players.find(x => x.id === localPlayerId);
        if (!p) return;

        const ageIndex = p.age;
        const ageData = GAME_DATA.ages[ageIndex];
        const nextAge = GAME_DATA.ages[ageIndex + 1];

        let displayGold = p.gold;
        if (!isHost) {
            pendingQueue.forEach(req => { displayGold -= req.cost; });
        }
        
        document.getElementById('stats-gold').innerText = Math.floor(Math.max(0, displayGold));
        document.getElementById('stats-xp').innerText = Math.floor(p.xp);
        
        // --- QUEUE UI (MERGED) ---
        const queueDiv = document.getElementById('queue-bar');
        let combinedQueue = p.spawnQueue ? [...p.spawnQueue] : [];
        combinedQueue = combinedQueue.concat(pendingQueue.map(pq => ({ unitId: pq.unitId })));

        if (combinedQueue.length > 0) {
            queueDiv.classList.remove('hidden');
            
            queueDiv.innerHTML = combinedQueue.map((item, idx) => {
                const uStats = getUnitStats(p.age, item.unitId);
                if (!uStats) return '';
                
                let progressHtml = '';
                if (idx === 0) {
                    // Use client timer exclusively
                    const t = p._clientTimer !== undefined ? p._clientTimer : (uStats.delay);
                    const pct = Math.min(100, Math.max(0, ((uStats.delay - t) / uStats.delay) * 100));
                    progressHtml = `<div class="queue-progress" style="width: ${pct}%"></div>`;
                }
                
                return `<div class="queue-item">${uStats.icon}${progressHtml}</div>`;
            }).join('');
        } else {
            queueDiv.classList.add('hidden');
            queueDiv.innerHTML = '';
        }


        // --- Unit Bar Construction ---
        const unitContainer = document.getElementById('unit-bar');
        
        if (currentRenderedAge !== ageIndex) {
            currentRenderedAge = ageIndex;
            
            unitContainer.innerHTML = ageData.units.map(u => `
                <div id="btn-unit-${u.id}" class="unit-card relative w-24 h-24 rounded cursor-pointer flex flex-col items-center justify-center" 
                     onclick="sendAction({type: 'queueUnit', unitId: '${u.id}'})">
                    <span class="text-5xl pointer-events-none">${u.icon}</span> 
                    <span class="text-base text-yellow-400 font-bold pointer-events-none">$${u.cost}</span>
                    <div class="tooltip pointer-events-none">
                        <b class="text-yellow-400 text-xl">${u.name}</b><br/>
                        <div class="grid grid-cols-2 gap-2 mt-1">
                            <span>‚ù§Ô∏è HP: ${u.hp}</span>
                            <span>‚è±Ô∏è Train: ${u.delay}s</span>
                            <span>‚öîÔ∏è Melee: ${u.meleeDmg} (${u.meleeRange})</span>
                            <span>üèπ Range: ${u.rangedDmg} (${u.rangedRange})</span>
                        </div>
                    </div>
                </div>
            `).join('');

            const specialBtn = document.getElementById('special-btn');
            if (ageData.special) {
                specialBtn.innerHTML = `<span class="pointer-events-none text-4xl">‚≠ê</span><span class="text-sm pointer-events-none">${ageData.special.name}</span><div id="special-cd-overlay" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center text-white font-bold hidden text-2xl"></div>`;
                specialBtn.onclick = () => {
                    input.mode = 'ability';
                    document.body.style.cursor = 'crosshair';
                };
                specialBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-800');
                specialBtn.classList.add('bg-purple-900', 'border-purple-500', 'hover:bg-purple-800');
            } else {
                specialBtn.innerHTML = 'Locked';
                specialBtn.onclick = null;
                specialBtn.classList.add('opacity-50', 'cursor-not-allowed', 'bg-gray-800');
                specialBtn.classList.remove('bg-purple-900', 'border-purple-500', 'hover:bg-purple-800');
            }
        }

        const cdOverlay = document.getElementById('special-cd-overlay');
        const specialBtn = document.getElementById('special-btn');
        if (p.specialCooldown > 0 && cdOverlay) {
             cdOverlay.classList.remove('hidden');
             cdOverlay.innerText = Math.ceil(p.specialCooldown);
             specialBtn.onclick = null; 
             specialBtn.classList.add('cursor-not-allowed');
        } else if (cdOverlay) {
             cdOverlay.classList.add('hidden');
             specialBtn.onclick = () => { input.mode = 'ability'; document.body.style.cursor = 'crosshair'; };
             specialBtn.classList.remove('cursor-not-allowed');
        }

        ageData.units.forEach(u => {
            const btn = document.getElementById(`btn-unit-${u.id}`);
            if (btn) {
                if (displayGold < u.cost) {
                    btn.classList.add('disabled');
                } else {
                    btn.classList.remove('disabled');
                }
            }
        });

        const upgradeBtn = document.getElementById('upgrade-btn');
        if (nextAge) {
            upgradeBtn.classList.remove('hidden');
            const canAfford = p.xp >= nextAge.xpReq;
            
            if (canAfford) {
                upgradeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                upgradeBtn.onclick = () => { sendAction({type: 'upgrade'}); };
            } else {
                upgradeBtn.classList.add('opacity-50', 'cursor-not-allowed');
                upgradeBtn.onclick = null;
            }
            upgradeBtn.innerHTML = `Evolve to ${nextAge.name}<br/><span class="text-xs">${nextAge.xpReq} XP</span>`;
        } else {
            upgradeBtn.classList.add('hidden');
        }
        
        const targetStatus = document.getElementById('target-status');
        if (p.targetId) {
            const t = simState.players.find(x => x.id === p.targetId);
            targetStatus.innerText = `Target: ${t ? t.name : 'Unknown'}`;
            targetStatus.classList.remove('text-red-400', 'animate-pulse');
            targetStatus.classList.add('text-white');
        } else {
            targetStatus.innerText = "Click a Base to Set Target!";
            targetStatus.classList.add('text-red-400', 'animate-pulse');
            targetStatus.classList.remove('text-white');
        }
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    
    function dist(x1, y1, x2, y2) {
        return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
    }
    
    function getTurretData(tid) {
        for(let a of GAME_DATA.ages) {
            if (a.turret && a.turret.id === tid) return a.turret;
        }
        return null;
    }

    // Move Init to DOMContentLoaded to ensure UI elements exist
    window.addEventListener('DOMContentLoaded', () => {
        initApp();
    });

</script>

<!-- === UI LAYOUT === -->
<div id="lobby-screen" class="screen w-full h-full flex flex-row items-center justify-center relative bg-gray-900 gap-8">
    <!-- Version -->
    <div class="absolute bottom-4 right-4 text-gray-600 text-sm">
        Build: <span id="version-display"></span>
    </div>

    <!-- MAIN MENU PANEL -->
    <div class="glass-panel p-8 rounded-xl max-w-md w-full text-center">
        <h1 class="text-5xl font-bold mb-6 text-yellow-500">Age of War: FFA</h1>
        <p class="mb-4 text-gray-300 text-xl">Multiplayer Strategy Game</p>
        
        <div id="auth-status" class="mb-6 text-base text-yellow-500 animate-pulse">Connecting...</div>

        <div class="flex flex-col gap-4">
            <input id="lobby-name" type="text" placeholder="Your Name" class="bg-gray-800 border border-gray-600 p-4 rounded text-white text-xl">
            
            <div class="flex items-center gap-4 bg-gray-800 p-3 rounded border border-gray-600">
                <span class="text-lg text-gray-300">Base Color:</span>
                <input id="player-color" type="color" value="#ff0000" class="flex-1">
            </div>
            
            <div class="flex items-center gap-2 justify-center text-gray-400 mb-2">
                 <input type="checkbox" id="is-private-lobby">
                 <label for="is-private-lobby">Private Game (Code Only)</label>
            </div>

            <button onclick="createLobby()" class="btn-primary w-full py-4 text-xl">Create New Game</button>
            
            <div class="flex gap-2 mt-4">
                <input id="lobby-id-input" type="text" placeholder="CODE" class="bg-gray-800 border border-gray-600 p-3 rounded flex-1 text-white text-base text-center uppercase tracking-widest">
                <button onclick="joinLobby()" class="bg-blue-600 hover:bg-blue-500 text-white px-6 rounded font-bold text-lg">Join</button>
            </div>
        </div>
    </div>
    
    <!-- PUBLIC BROWSER PANEL -->
    <div class="glass-panel p-6 rounded-xl w-80 h-96 flex flex-col">
        <h2 class="text-xl font-bold text-gray-300 mb-4 border-b border-gray-600 pb-2">Public Games</h2>
        <div id="active-lobbies-list" class="flex-1 overflow-y-auto pr-2">
            <!-- Injected -->
            <div class="text-gray-500 text-sm text-center mt-10">Loading...</div>
        </div>
    </div>
</div>

<div id="waiting-room" class="screen hidden w-full h-full flex flex-col items-center justify-center bg-gray-900">
    <div class="glass-panel p-8 rounded-xl max-w-lg w-full">
        <h2 class="text-3xl font-bold mb-4">Lobby</h2>
        <div id="copy-box" class="bg-black p-4 rounded mb-6 text-base font-mono text-gray-400 cursor-pointer transition flex justify-between items-center" onclick="copyLobbyId()">
            <span>Code: <span id="display-lobby-id" class="text-white font-bold select-all text-xl tracking-widest"></span></span>
            <span class="text-xs bg-gray-700 px-2 py-1 rounded">COPY</span>
        </div>
        
        <div class="mb-6">
            <h3 class="text-lg text-gray-400 mb-2">Players</h3>
            <div id="player-list" class="max-h-60 overflow-y-auto text-lg"></div>
        </div>

        <div class="flex gap-4 mb-4">
            <button id="add-bot-btn" onclick="addBot()" class="bg-gray-600 hover:bg-gray-500 text-white px-6 py-3 rounded flex-1 text-lg">Add Bot</button>
            <button id="start-btn" onclick="setGameStarted()" class="btn-primary flex-1 text-lg">Start Game</button>
        </div>
        
        <div class="border-t border-gray-700 pt-4 flex flex-col items-center">
             <button id="leave-btn" onclick="leaveLobby()" class="text-red-500 hover:text-red-400 text-sm underline">Leave Lobby</button>
             <span id="leave-msg" class="text-xs text-gray-500 mt-1"></span>
        </div>
        
        <p class="mt-4 text-sm text-center text-gray-500">Waiting for host to start...</p>
    </div>
</div>

<div id="game-screen" class="screen hidden w-full h-full">
    <canvas id="game-canvas"></canvas>

    <!-- Connection Overlay -->
    <div id="connection-overlay" class="absolute inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center hidden">
        <div class="glass-panel p-8 rounded-xl text-center">
            <h2 id="connection-msg" class="text-3xl font-bold text-red-500 mb-2">Connection Lost</h2>
            <p class="text-gray-300">Waiting for Host...</p>
        </div>
    </div>

    <!-- HUD -->
    <div class="game-ui flex flex-col justify-between p-6">
        <!-- Top Bar -->
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="glass-panel p-4 rounded flex gap-6 text-base">
                <div class="flex flex-col">
                    <span class="text-yellow-400 font-bold text-lg">GOLD</span>
                    <span id="stats-gold" class="text-3xl">0</span>
                </div>
                <div class="flex flex-col border-l border-gray-600 pl-6">
                    <span class="text-blue-400 font-bold text-lg">XP</span>
                    <span id="stats-xp" class="text-3xl">0</span>
                </div>
            </div>
            
            <div id="target-status" class="glass-panel px-6 py-3 rounded font-bold text-red-400 animate-pulse text-xl">
                Select Target
            </div>
            
            <div class="glass-panel p-3 rounded">
                <button id="upgrade-btn" class="btn-primary text-lg hidden p-4">Evolve</button>
            </div>
        </div>

        <!-- Bottom Bar -->
        <div class="flex flex-col items-center gap-4 pointer-events-auto pb-6">
            <!-- Queue Display -->
            <div id="queue-bar" class="flex gap-2 mb-2 hidden">
                <!-- Items injected here -->
            </div>

            <!-- Controls -->
            <div class="flex items-end gap-6">
                <!-- Special -->
                <button id="special-btn" class="relative w-24 h-24 rounded bg-purple-900 border-2 border-purple-500 hover:bg-purple-800 flex flex-col items-center justify-center transition overflow-hidden">
                    Locked
                </button>

                <!-- Units -->
                <div id="unit-bar" class="flex gap-4 glass-panel p-4 rounded-xl">
                    <!-- Injected via JS -->
                </div>
            </div>
        </div>
    </div>
</div>

</body>
</html>