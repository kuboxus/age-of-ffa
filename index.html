<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Age of War: Multiplayer</title>
    
    <!-- Firebase Imports -->
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #111; color: white; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; touch-action: none; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #222; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }

        .game-ui { position: absolute; pointer-events: none; width: 100%; height: 100%; top: 0; left: 0; }
        .pointer-events-auto { pointer-events: auto; }
        
        .unit-card { transition: all 0.05s; background: rgba(0,0,0,0.8); border: 2px solid #444; }
        .unit-card:hover { border-color: #fff; transform: translateY(-2px); }
        .unit-card:active { transform: translateY(0); border-color: #eab308; }
        .unit-card.disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }

        .btn-primary { background: #eab308; color: #000; font-weight: bold; padding: 8px 16px; border-radius: 4px; transition: 0.2s; }
        .btn-primary:hover { background: #facc15; }
        .btn-danger { background: #ef4444; color: #fff; font-weight: bold; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
        .btn-danger:hover { background: #dc2626; }
        
        .tooltip { display: none; position: absolute; background: rgba(0,0,0,0.9); border: 1px solid #666; padding: 12px; border-radius: 6px; font-size: 14px; z-index: 100; pointer-events: none; width: 260px; text-align: left; }
        .unit-card:hover .tooltip { display: block; bottom: 110%; left: 50%; transform: translateX(-50%); }

        #lobby-screen { background: url('data:image/svg+xml;utf8,<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g fill="%23222"><path d="M0 0h50v50H0zM50 50h50v50H50z"/></g></svg>'); }
        
        .glass-panel { background: rgba(20, 20, 20, 0.9); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 4px 30px rgba(0,0,0,0.5); }
        
        /* Queue items */
        .queue-item { width: 45px; height: 45px; border: 1px solid #666; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; font-size: 24px; position: relative; }
        .queue-progress { position: absolute; bottom: 0; left: 0; height: 3px; background: #0f0; transition: width 0.1s linear; }
        
        input[type="color"] { -webkit-appearance: none; border: none; width: 40px; height: 40px; cursor: pointer; background: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid #666; border-radius: 8px; }

        .lobby-list-item { cursor: pointer; transition: background 0.2s; }
        .lobby-list-item:hover { background: rgba(255,255,255,0.1); }

        /* Range Slider Styling */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #eab308; cursor: pointer; margin-top: -6px; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #444; border-radius: 2px; }
    </style>
</head>
<body>

<!-- === INITIALIZATION & DATA === -->
<script>
    // --- Configuration ---
    const VERSION = "v3.0-Teams";
    
    // Default Gameplay Settings
    const DEFAULT_SETTINGS = {
        mode: 'FFA', // 'FFA' or 'TEAMS'
        gameSpeed: 1.0,
        unitCost: 1.0,
        goldMult: 1.0,
        xpMult: 1.0,
        baseHp: 2500,
        xpReq: 1.0,
        layout: 'alternating' // 'together' or 'alternating' (checkerboard)
    };

    const TEAMS = {
        1: { name: "Blue Team", color: "#3b82f6" },
        2: { name: "Red Team", color: "#ef4444" }
    };
    
    const GAME_DATA = {
        ages: [
            {
                name: "Stone Age",
                xpReq: 0,
                special: { name: "Meteor Strike", damage: 200, radius: 100, cooldown: 60 },
                units: [
                    { id: 'u1_1', name: "Club Man", icon: "ðŸª¨", cost: 15, delay: 1.0, hp: 55, meleeDmg: 16, rangedDmg: 0, meleeRange: 20, rangedRange: 0 },
                    { id: 'u1_2', name: "Slingshot Man", icon: "ðŸ§¶", cost: 25, delay: 1.0, hp: 42, meleeDmg: 10, rangedDmg: 8, meleeRange: 20, rangedRange: 100 },
                    { id: 'u1_3', name: "Dino Rider", icon: "ðŸ¦–", cost: 100, delay: 3.0, hp: 160, meleeDmg: 40, rangedDmg: 0, meleeRange: 45, rangedRange: 0 }
                ],
                turret: { id: 't1', name: "Rock Catapult", icon: "ðŸªµ", cost: 100, damage: 25, range: 200, cooldown: 80 }
            },
            {
                name: "Medieval Age",
                xpReq: 1000,
                special: { name: "Arrow Rain", damage: 400, radius: 120, cooldown: 70 },
                units: [
                    { id: 'u2_1', name: "Sword Man", icon: "âš”ï¸", cost: 50, delay: 2.0, hp: 100, meleeDmg: 32, rangedDmg: 0, meleeRange: 20, rangedRange: 0 },
                    { id: 'u2_2', name: "Archer", icon: "ðŸ¹", cost: 75, delay: 1.0, hp: 80, meleeDmg: 20, rangedDmg: 9, meleeRange: 20, rangedRange: 130 },
                    { id: 'u2_3', name: "Knight", icon: "ðŸ´", cost: 500, delay: 3.0, hp: 300, meleeDmg: 60, rangedDmg: 0, meleeRange: 60, rangedRange: 0 }
                ],
                turret: { id: 't2', name: "Ballista", icon: "ðŸ¹", cost: 400, damage: 50, range: 250, cooldown: 70 }
            },
            {
                name: "Renaissance",
                xpReq: 4000,
                special: { name: "Artillery Strike", damage: 800, radius: 150, cooldown: 80 },
                units: [
                    { id: 'u3_1', name: "Duelist", icon: "ðŸ—¡ï¸", cost: 200, delay: 3.0, hp: 200, meleeDmg: 79, rangedDmg: 0, meleeRange: 25, rangedRange: 0 },
                    { id: 'u3_2', name: "Musketeer", icon: "ðŸ”«", cost: 400, delay: 3.0, hp: 160, meleeDmg: 40, rangedDmg: 20, meleeRange: 25, rangedRange: 130 },
                    { id: 'u3_3', name: "Cannoneer", icon: "ðŸ’£", cost: 1000, delay: 5.0, hp: 600, meleeDmg: 120, rangedDmg: 0, meleeRange: 25, rangedRange: 0 }
                ],
                turret: { id: 't3', name: "Cannon Turret", icon: "ðŸ’£", cost: 1000, damage: 120, range: 300, cooldown: 120 }
            },
            {
                name: "Modern Age",
                xpReq: 16000,
                special: { name: "Airstrike", damage: 1500, radius: 180, cooldown: 90 },
                units: [
                    { id: 'u4_1', name: "Melee Infantry", icon: "ðŸŽ–ï¸", cost: 1500, delay: 3.0, hp: 300, meleeDmg: 100, rangedDmg: 0, meleeRange: 25, rangedRange: 0 },
                    { id: 'u4_2', name: "Machine Gunner", icon: "ðŸ”«", cost: 2000, delay: 3.0, hp: 350, meleeDmg: 60, rangedDmg: 30, meleeRange: 25, rangedRange: 130 }, 
                    { id: 'u4_3', name: "Tank", icon: "ðŸšœ", cost: 7000, delay: 8.0, hp: 1200, meleeDmg: 300, rangedDmg: 0, meleeRange: 100, rangedRange: 0 }
                ],
                turret: { id: 't4', name: "Machine Gun", icon: "ðŸ”«", cost: 4000, damage: 50, range: 350, cooldown: 10 }
            },
            {
                name: "Future Age",
                xpReq: 60000,
                special: { name: "Ion Cannon", damage: 6000, radius: 250, cooldown: 120 },
                units: [
                    { id: 'u5_1', name: "Alien Blade", icon: "ðŸ‘½", cost: 5000, delay: 3.0, hp: 1000, meleeDmg: 250, rangedDmg: 0, meleeRange: 40, rangedRange: 0 },
                    { id: 'u5_2', name: "Alien Blaster", icon: "âš¡", cost: 6000, delay: 3.0, hp: 800, meleeDmg: 130, rangedDmg: 80, meleeRange: 40, rangedRange: 130 },
                    { id: 'u5_3', name: "War Machine", icon: "ðŸ‘¹", cost: 20000, delay: 8.0, hp: 3000, meleeDmg: 600, rangedDmg: 0, meleeRange: 100, rangedRange: 0 },
                    { id: 'u5_4', name: "Super Soldier", icon: "ðŸ¦¸", cost: 150000, delay: 3.0, hp: 4000, meleeDmg: 400, rangedDmg: 400, meleeRange: 40, rangedRange: 150 }
                ],
                turret: { id: 't5', name: "Laser Battery", icon: "âš¡", cost: 15000, damage: 800, range: 450, cooldown: 60 }
            }
        ],
        turretSlots: 2,
        mapRadius: 1000,
        baseRadius: 90, 
        unitCollisionRadius: 20 
    };
    
    // Globals
    let db, auth, user;
    let appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';
    let lobbyId = null;
    let isHost = false;
    let localPlayerId = null;
    let gameLoopRef = null;
    let gameState = null;
    let canvas, ctx;
    let camera = { x: 0, y: 0, zoom: 0.8 };
    let input = { keys: {}, mouse: { x: 0, y: 0, down: false }, targetId: null, mode: 'select' }; 
    let lastUnitBuyTime = 0; 
    let lastUpdateReceived = Date.now(); 
    let activeSettings = { ...DEFAULT_SETTINGS }; // Settings active in current game
    let lobbySettings = { ...DEFAULT_SETTINGS }; // Settings currently in lobby UI
    
    // --- NETWORKING & PREDICTION STATE ---
    let renderState = {
        units: new Map(), 
        projectiles: [] 
    };
    
    let pendingQueue = []; 
    
    const getLobbyRef = () => db.collection('artifacts').doc(appId).collection('public').doc('data').collection('lobbies');

    async function initApp() {
        const names = ["Warlord", "Strategist", "Commander", "General", "Captain", "Tactician", "Emperor", "King"];
        const randomName = names[Math.floor(Math.random() * names.length)] + " " + Math.floor(Math.random() * 1000);
        const nameInput = document.getElementById('lobby-name');
        if(nameInput) nameInput.value = randomName;
        
        const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
        const colorInput = document.getElementById('player-color');
        if(colorInput) colorInput.value = randomColor;

        const firebaseConfig = {
			apiKey: "AIzaSyAhVZB64ov5te0w5he0zeCNuOZuy7jUpuI",
			authDomain: "ageofffa.firebaseapp.com",
			projectId: "ageofffa",
			storageBucket: "ageofffa.firebasestorage.app",
			messagingSenderId: "461491837298",
			appId: "1:461491837298:web:daebae2fb46fe3eb3ee5eb"
		};
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        db = firebase.firestore();
        auth = firebase.auth();

        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            await auth.signInWithCustomToken(__initial_auth_token);
        } else {
            await auth.signInAnonymously();
        }

        auth.onAuthStateChanged(u => {
            user = u;
            if (user) {
                localPlayerId = user.uid;
                document.getElementById('auth-status').innerText = `Connected (${VERSION})`;
                document.getElementById('auth-status').classList.add('text-green-500');
                document.getElementById('version-display').innerText = VERSION;
                showScreen('lobby-screen');
                startLobbyBrowser();
            }
        });
    }
    
    // --- Active Lobby Browser ---
    function startLobbyBrowser() {
        getLobbyRef().onSnapshot(snapshot => {
            const listEl = document.getElementById('active-lobbies-list');
            if(!listEl) return;
            listEl.innerHTML = '';
            const activeLobbies = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                if (data.status === 'waiting' && !data.isPrivate) {
                    activeLobbies.push({ id: doc.id, ...data });
                }
            });
            
            if (activeLobbies.length === 0) {
                listEl.innerHTML = '<div class="text-gray-500 text-sm text-center">No active public games found.</div>';
                return;
            }

            activeLobbies.forEach(lobby => {
                const el = document.createElement('div');
                el.className = 'lobby-list-item bg-gray-800 border border-gray-600 p-2 rounded mb-2 flex justify-between items-center';
                const modeLabel = lobby.settings?.mode === 'TEAMS' ? '<span class="text-xs bg-purple-600 px-1 rounded ml-2">TEAMS</span>' : '';
                el.innerHTML = `
                    <div>
                        <div class="font-bold text-yellow-500">${lobby.name} ${modeLabel}</div>
                        <div class="text-xs text-gray-400">Players: ${lobby.players.length}</div>
                    </div>
                    <button class="bg-blue-600 text-xs px-2 py-1 rounded">Join</button>
                `;
                el.onclick = () => {
                    document.getElementById('lobby-id-input').value = lobby.id;
                    joinLobby();
                };
                listEl.appendChild(el);
            });
        });
    }

    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    }

    // --- Lobby Logic ---
    async function createLobby() {
        const lobbyNameVal = document.getElementById('lobby-name').value || "New Game";
        const playerNameVal = document.getElementById('lobby-name').value || "Player 1";
        const colorVal = document.getElementById('player-color').value || "#ff0000";
        const isPrivate = document.getElementById('is-private-lobby').checked;
        
        const shortCode = Math.random().toString(36).substring(2, 8).toUpperCase();
        lobbyId = shortCode;
        
        const initialPlayer = createPlayerObj(localPlayerId, playerNameVal, false, colorVal);
        // Host defaults to Team 1 if modes switch later
        initialPlayer.team = 1;

        await getLobbyRef().doc(shortCode).set({
            hostId: localPlayerId,
            name: lobbyNameVal,
            status: 'waiting',
            isPrivate: isPrivate,
            players: [initialPlayer],
            settings: { ...DEFAULT_SETTINGS },
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            lastHeartbeat: firebase.firestore.FieldValue.serverTimestamp(),
            stateJSON: JSON.stringify({ units: [], projectiles: [], effects: [] }),
            actions: []
        });

        enterLobbyUI(lobbyId, true);
    }

    async function joinLobby() {
        let id = document.getElementById('lobby-id-input').value.trim();
        const playerNameVal = document.getElementById('lobby-name').value || "Player";
        const colorVal = document.getElementById('player-color').value || "#00ff00";

        if(!id) return alert("Enter Lobby ID");
        if (id.length <= 8) id = id.toUpperCase();
        
        const lobbyRef = getLobbyRef().doc(id);
        const doc = await lobbyRef.get();
        
        if(!doc.exists) return alert("Lobby not found");
        if(doc.data().status !== 'waiting') return alert("Game already started");

        // Determine team balancing
        const currentPlayers = doc.data().players;
        const t1Count = currentPlayers.filter(p => p.team === 1).length;
        const t2Count = currentPlayers.filter(p => p.team === 2).length;
        const autoTeam = t1Count <= t2Count ? 1 : 2;

        const newPlayer = createPlayerObj(localPlayerId, playerNameVal, false, colorVal);
        newPlayer.team = autoTeam; // Assign balanced team by default
        
        await db.runTransaction(async (t) => {
            const fresh = await t.get(lobbyRef);
            if (!fresh.exists) throw "Lobby gone";
            const players = fresh.data().players;
            if (players.find(p => p.id === localPlayerId)) return; 
            if (players.length >= 10) throw "Lobby Full";
            players.push(newPlayer);
            t.update(lobbyRef, { players: players });
        });

        lobbyId = id;
        enterLobbyUI(lobbyId, false);
    }

    function createPlayerObj(id, name, isBot, color) {
        return {
            id: id,
            name: name,
            isBot: isBot,
            age: 0,
            xp: 0,
            gold: 300,
            hp: 2500, // Will be overridden by settings on start
            maxHp: 2500,
            turrets: [], 
            targetId: null, 
            color: color || `hsl(${Math.random() * 360}, 70%, 50%)`,
            spawnQueue: [], 
            spawnTimer: 0, 
            _visualTimer: 0, 
            specialCooldown: 0,
            team: 0 // 0=FFA, 1=Team1, 2=Team2
        };
    }
    
    async function updateLobbySettings() {
        if(!isHost || !lobbyId) return;
        
        // Harvest from UI
        const newSettings = {
            mode: document.getElementById('set-mode').value,
            gameSpeed: parseFloat(document.getElementById('set-speed').value),
            unitCost: parseFloat(document.getElementById('set-cost').value),
            goldMult: parseFloat(document.getElementById('set-gold').value),
            xpMult: parseFloat(document.getElementById('set-xp').value),
            baseHp: parseInt(document.getElementById('set-hp').value),
            xpReq: parseFloat(document.getElementById('set-xpreq').value),
            layout: document.getElementById('set-layout').value
        };
        
        await getLobbyRef().doc(lobbyId).update({ settings: newSettings });
    }

    async function switchTeam(targetId, newTeam) {
        if (!lobbyId) return;
        // Only host can force others, but players can switch themselves
        if (targetId !== localPlayerId && !isHost) return;

        await db.runTransaction(async (t) => {
             const ref = getLobbyRef().doc(lobbyId);
             const doc = await t.get(ref);
             const players = doc.data().players;
             const p = players.find(x => x.id === targetId);
             if (p) {
                 p.team = newTeam;
                 t.update(ref, { players: players });
             }
        });
    }

    async function resetSettings() {
        if(!isHost) return;
        await getLobbyRef().doc(lobbyId).update({ settings: DEFAULT_SETTINGS });
    }
    
    async function kickPlayer(targetId) {
        if (!isHost || !lobbyId) return;
        await db.runTransaction(async (t) => {
             const ref = getLobbyRef().doc(lobbyId);
             const doc = await t.get(ref);
             const players = doc.data().players.filter(p => p.id !== targetId);
             t.update(ref, { players: players });
        });
    }

    async function leaveLobby() {
        if (!lobbyId) return;
        if (lobbyUnsub) lobbyUnsub();
        lobbyUnsub = null;
        const ref = getLobbyRef().doc(lobbyId);
        await db.runTransaction(async (t) => {
             const doc = await t.get(ref);
             if (!doc.exists) return;
             const data = doc.data();
             const newPlayers = data.players.filter(p => p.id !== localPlayerId);
             if (newPlayers.length === 0) t.delete(ref);
             else {
                 let updates = { players: newPlayers };
                 if (data.hostId === localPlayerId) updates.hostId = newPlayers[0].id;
                 t.update(ref, updates);
             }
        });
        location.reload();
    }

    let hasSeenSelfInLobby = false; 

    function enterLobbyUI(id, host) {
        isHost = host;
        showScreen('waiting-room');
        document.getElementById('display-lobby-id').innerText = id;
        
        hasSeenSelfInLobby = false; 

        // Initial UI state for host vs client
        const inputs = document.querySelectorAll('#settings-panel input, #settings-panel select');
        inputs.forEach(inp => inp.disabled = !isHost);
        if(!isHost) {
            document.getElementById('reset-btn').classList.add('hidden');
            document.getElementById('start-btn').classList.add('hidden');
            document.getElementById('add-bot-btn').classList.add('hidden');
        } else {
             document.getElementById('reset-btn').classList.remove('hidden');
             document.getElementById('start-btn').classList.remove('hidden');
             document.getElementById('add-bot-btn').classList.remove('hidden');
        }

        lobbyUnsub = getLobbyRef().doc(id).onSnapshot(doc => {
            if(!doc.exists) { alert("Lobby closed."); location.reload(); return; }
            const data = doc.data();
            
            // Validate presence
            const amIIn = data.players.find(p => p.id === localPlayerId);
            if (amIIn) hasSeenSelfInLobby = true;
            else if (hasSeenSelfInLobby) { alert("You have been kicked."); location.reload(); return; }

            // Host check
            isHost = (data.hostId === localPlayerId);
            inputs.forEach(inp => inp.disabled = !isHost);
            document.getElementById('reset-btn').classList.toggle('hidden', !isHost);
            document.getElementById('start-btn').classList.toggle('hidden', !isHost);
            document.getElementById('add-bot-btn').classList.toggle('hidden', !isHost);

            // Sync Settings to UI
            lobbySettings = data.settings || DEFAULT_SETTINGS;
            
            // Only update input values if we are NOT the host (to avoid typing interference)
            // Or if we are host but we want to sync initial load
            if (!isHost) {
                document.getElementById('set-mode').value = lobbySettings.mode;
                document.getElementById('set-speed').value = lobbySettings.gameSpeed;
                document.getElementById('set-cost').value = lobbySettings.unitCost;
                document.getElementById('set-gold').value = lobbySettings.goldMult;
                document.getElementById('set-xp').value = lobbySettings.xpMult;
                document.getElementById('set-hp').value = lobbySettings.baseHp;
                document.getElementById('set-xpreq').value = lobbySettings.xpReq;
                document.getElementById('set-layout').value = lobbySettings.layout;
            }
            
            // Update Labels
            document.getElementById('val-speed').innerText = lobbySettings.gameSpeed + 'x';
            document.getElementById('val-cost').innerText = lobbySettings.unitCost + 'x';
            document.getElementById('val-gold').innerText = lobbySettings.goldMult + 'x';
            document.getElementById('val-xp').innerText = lobbySettings.xpMult + 'x';
            document.getElementById('val-hp').innerText = lobbySettings.baseHp;
            document.getElementById('val-xpreq').innerText = lobbySettings.xpReq + 'x';

            // Show/Hide Team/FFA options
            const teamControls = document.querySelectorAll('.team-only');
            teamControls.forEach(el => {
                if(lobbySettings.mode === 'TEAMS') el.classList.remove('hidden');
                else el.classList.add('hidden');
            });

            // Player List
            const list = document.getElementById('player-list');
            list.innerHTML = data.players.map(p => {
                let kickBtn = (isHost && p.id !== localPlayerId) ? `<button onclick="kickPlayer('${p.id}')" class="btn-danger ml-2">X</button>` : '';
                
                let teamBadge = '';
                let teamSwitch = '';
                if (lobbySettings.mode === 'TEAMS') {
                    const tColor = p.team === 1 ? 'bg-blue-600' : (p.team === 2 ? 'bg-red-600' : 'bg-gray-600');
                    teamBadge = `<span class="text-xs px-2 py-1 rounded ${tColor} font-bold mr-2">T${p.team}</span>`;
                    
                    // Allow switching
                    if (p.id === localPlayerId || isHost) {
                         const otherTeam = p.team === 1 ? 2 : 1;
                         const otherColor = otherTeam === 1 ? 'text-blue-400' : 'text-red-400';
                         teamSwitch = `<button onclick="switchTeam('${p.id}', ${otherTeam})" class="text-xs border border-gray-500 px-2 py-1 rounded hover:bg-gray-700 ml-2 ${otherColor}">Switch to T${otherTeam}</button>`;
                    }
                }

                return `
                <div class="flex items-center justify-between bg-gray-700 p-2 rounded mb-1">
                    <div class="flex items-center gap-2">
                        ${teamBadge}
                        <div class="w-3 h-3 rounded-full" style="background:${p.color}"></div>
                        <span class="${p.id === localPlayerId ? 'text-yellow-300 font-bold' : ''}">${p.name} ${p.isBot ? '(BOT)' : ''}</span>
                    </div>
                    <div class="flex items-center">
                        ${teamSwitch}
                        ${p.id === data.hostId ? '<span class="text-xs text-yellow-500 mr-2 ml-2">HOST</span>' : ''}
                        ${kickBtn}
                    </div>
                </div>`;
            }).join('');

            if(data.status === 'playing' || data.status === 'paused') {
                startGame(data);
            } else if (data.status === 'finished') {
                if (gameState !== 'finished') {
                    gameState = 'finished';
                    let resultText = "GAME OVER";
                    let resultColor = "text-white";
                    
                    if (lobbySettings.mode === 'TEAMS') {
                        const myP = data.players.find(p => p.id === localPlayerId);
                        const winnerTeam = data.winnerTeam;
                        if (myP && myP.team === winnerTeam) {
                            resultText = "VICTORY!";
                            resultColor = "text-blue-400";
                        } else {
                            resultText = "DEFEAT";
                            resultColor = "text-red-500";
                        }
                    } else {
                        const amIWinner = data.winner?.id === localPlayerId;
                        resultText = amIWinner ? "VICTORY!" : "DEFEAT";
                        resultColor = amIWinner ? "text-yellow-400" : "text-red-500";
                    }
                    
                    const overlay = document.createElement('div');
                    overlay.className = "absolute inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center z-50 pointer-events-auto";
                    overlay.innerHTML = `
                        <h1 class="text-6xl font-bold ${resultColor} mb-4">${resultText}</h1>
                        <p class="text-2xl text-white mb-8">Winner: ${data.winner?.name || (data.winnerTeam ? "Team " + data.winnerTeam : 'Unknown')}</p>
                        <button onclick="location.reload()" class="btn-primary">Back to Menu</button>
                    `;
                    document.body.appendChild(overlay);
                }
            }
        });
    }

    function copyLobbyId() {
        const idText = document.getElementById('display-lobby-id').innerText;
        navigator.clipboard.writeText(idText);
        const btn = document.getElementById('copy-box');
        btn.style.background = '#225522';
        setTimeout(() => { btn.style.background = ''; }, 200);
    }

    async function addBot() {
        if(!isHost) return;
        const ref = getLobbyRef().doc(lobbyId);
        const doc = await ref.get();
        const players = doc.data().players;
        if(players.length >= 10) return alert("Lobby full");
        
        // Auto assign team for bot
        const t1 = players.filter(p => p.team === 1).length;
        const t2 = players.filter(p => p.team === 2).length;
        const botTeam = t1 <= t2 ? 1 : 2;

        const bot = createPlayerObj('bot_' + Date.now(), "Bot " + Math.floor(Math.random()*100), true, `hsl(${Math.random() * 360}, 70%, 50%)`);
        bot.team = botTeam;
        players.push(bot);
        await ref.update({ players });
    }

    async function setGameStarted() {
        if(!isHost) return;
        await getLobbyRef().doc(lobbyId).update({ status: 'playing' });
    }

    // --- Game Logic ---

    let simState = { players: [], units: [], projectiles: [], effects: [] };
    
    function startGame(initialData) {
        if(lobbyUnsub) lobbyUnsub();
        showScreen('game-screen');
        
        canvas = document.getElementById('game-canvas');
        ctx = canvas.getContext('2d');
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        activeSettings = initialData.settings || DEFAULT_SETTINGS;
        simState.players = initialData.players;
        
        // --- MAP POSITIONING LOGIC ---
        // Sort players based on layout setting
        if (activeSettings.mode === 'TEAMS') {
            if (activeSettings.layout === 'together') {
                // [T1, T1, T2, T2]
                simState.players.sort((a,b) => a.team - b.team);
            } else if (activeSettings.layout === 'alternating') {
                // [T1, T2, T1, T2] - attempt to zipper merge
                const t1 = simState.players.filter(p => p.team === 1);
                const t2 = simState.players.filter(p => p.team === 2);
                const combined = [];
                const maxLen = Math.max(t1.length, t2.length);
                for(let i=0; i<maxLen; i++) {
                    if(t1[i]) combined.push(t1[i]);
                    if(t2[i]) combined.push(t2[i]);
                }
                simState.players = combined;
            }
        } else {
             // Random shuffle for FFA
             simState.players.sort(() => Math.random() - 0.5);
        }

        const radius = GAME_DATA.mapRadius * 0.8;
        const center = { x: 0, y: 0 };
        const angleStep = (Math.PI * 2) / simState.players.length;
        
        simState.players.forEach((p, i) => {
            const angle = angleStep * i;
            p.x = center.x + Math.cos(angle) * radius;
            p.y = center.y + Math.sin(angle) * radius;
            
            // Apply Settings
            p.maxHp = activeSettings.baseHp;
            p.hp = activeSettings.baseHp;
            
            // Apply Team Colors
            if (activeSettings.mode === 'TEAMS' && p.team > 0) {
                 p.color = TEAMS[p.team].color;
            }

            const ageData = GAME_DATA.ages[p.age];
            if(ageData && ageData.turret) {
                 p.turrets = [{ id: 'base_turret', typeId: ageData.turret.id, cooldown: 0, slot: 0 }];
            }
            if(p._visualTimer === undefined) p._visualTimer = 0;
        });

        // Input Listeners
        let isDragging = false, lastPos = {x:0, y:0};
        const getPos = (e) => {
            if (e.changedTouches) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        };
        const onDown = (e) => {
            if (e.button === 2) { 
                input.mode = 'select'; document.body.style.cursor = 'default';
                return;
            }
            isDragging = false;
            const p = getPos(e);
            input.mouse.down = true; input.mouse.x = p.x; input.mouse.y = p.y; lastPos = p;
        };
        const onMove = (e) => {
            e.preventDefault(); 
            const p = getPos(e); input.mouse.x = p.x; input.mouse.y = p.y;
            if (input.mouse.down) {
                const dx = p.x - lastPos.x; const dy = p.y - lastPos.y;
                if (Math.abs(dx) > 2 || Math.abs(dy) > 2) isDragging = true;
                if (isDragging) { camera.x -= dx / camera.zoom; camera.y -= dy / camera.zoom; lastPos = p; }
            }
        };
        const onUp = (e) => {
            input.mouse.down = false;
            if (!isDragging && e.button === 0) handleInput();
            isDragging = false;
        };
        canvas.addEventListener('mousedown', onDown); canvas.addEventListener('mousemove', onMove); canvas.addEventListener('mouseup', onUp);
        canvas.addEventListener('touchstart', onDown, {passive: false}); canvas.addEventListener('touchmove', onMove, {passive: false}); canvas.addEventListener('touchend', onUp);
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            camera.zoom = Math.max(0.2, Math.min(camera.zoom * (1 - e.deltaY * 0.001), 2.5));
        });
        window.addEventListener('contextmenu', e => e.preventDefault());

        const me = simState.players.find(p => p.id === localPlayerId);
        if (me) { camera.x = me.x; camera.y = me.y; }

        if(isHost) {
            document.addEventListener('visibilitychange', () => {
                getLobbyRef().doc(lobbyId).update({ status: document.hidden ? 'paused' : 'playing' });
            });
            requestAnimationFrame(hostGameLoop);
            setInterval(hostSync, 200); 
        } else {
            getLobbyRef().doc(lobbyId).onSnapshot(doc => {
                if(!doc.exists) return;
                const d = doc.data();
                lastUpdateReceived = Date.now();
                document.getElementById('connection-overlay').classList.toggle('hidden', d.status !== 'paused');

                if(d.stateJSON) {
                    const parsed = JSON.parse(d.stateJSON);
                    
                    d.players.forEach(serverPlayer => {
                        const localP = simState.players.find(p => p.id === serverPlayer.id);
                        if (localP) {
                            localP.gold = serverPlayer.gold;
                            localP.xp = serverPlayer.xp;
                            localP.hp = serverPlayer.hp;
                            localP.age = serverPlayer.age;
                            localP.targetId = serverPlayer.targetId;
                            
                            const oldHead = localP.spawnQueue?.[0]?.reqId;
                            const newHead = serverPlayer.spawnQueue?.[0]?.reqId;
                            if (oldHead !== newHead && newHead) {
                                const stats = getUnitStats(localP.age, serverPlayer.spawnQueue[0].unitId);
                                localP._visualTimer = stats ? stats.delay : 0;
                            } else if (serverPlayer.spawnQueue.length > 0 && Math.abs((localP._visualTimer || 0) - serverPlayer.spawnTimer) > 0.3) {
                                localP._visualTimer = serverPlayer.spawnTimer;
                            }
                            localP.spawnQueue = serverPlayer.spawnQueue;
                        }
                    });
                    
                    if (simState.players.length === 0) simState.players = d.players;

                    const me = simState.players.find(p => p.id === localPlayerId);
                    if(me && me.spawnQueue) {
                        const sIds = new Set(me.spawnQueue.map(i => i.reqId));
                        pendingQueue = pendingQueue.filter(p => !sIds.has(p.reqId));
                    }
                    
                    simState.projectiles = parsed.projectiles;
                    simState.effects = parsed.effects;
                    
                    parsed.units.forEach(serverUnit => {
                        if (renderState.units.has(serverUnit.id)) {
                            const u = renderState.units.get(serverUnit.id);
                            u.targetX = serverUnit.x; u.targetY = serverUnit.y; u.hp = serverUnit.hp; u.maxHp = serverUnit.maxHp;
                        } else {
                            renderState.units.set(serverUnit.id, { ...serverUnit, x: serverUnit.x, y: serverUnit.y, targetX: serverUnit.x, targetY: serverUnit.y });
                        }
                    });
                    const serverIds = new Set(parsed.units.map(u => u.id));
                    for (let [id, u] of renderState.units) { if (!serverIds.has(id)) renderState.units.delete(id); }
                    simState.units = Array.from(renderState.units.values());
                }
            });
            requestAnimationFrame(clientRenderLoop);
        }
        updateUI();
    }

    // --- Host Simulation ---
    const TICK_RATE = 1 / 30; 
    let lastTime = performance.now(), accumulator = 0, syncTimer = 0;

    function hostGameLoop(time) {
        if (gameState === 'finished') return;
        if (document.hidden) { lastTime = time; requestAnimationFrame(hostGameLoop); return; }

        let dt = (time - lastTime) / 1000;
        lastTime = time;
        if (dt > 0.25) dt = 0.25;
        accumulator += dt;

        while (accumulator >= TICK_RATE) {
            updateHostLogic(TICK_RATE);
            accumulator -= TICK_RATE;
        }
        
        syncTimer += dt;
        if (syncTimer > 0.1) { hostSyncState(); syncTimer = 0; }

        renderGame(0);
        updateUI();
        requestAnimationFrame(hostGameLoop);
    }

    function isTeammate(p1Id, p2Id) {
        if (activeSettings.mode !== 'TEAMS') return false;
        const p1 = simState.players.find(p => p.id === p1Id);
        const p2 = simState.players.find(p => p.id === p2Id);
        if (!p1 || !p2) return false;
        return p1.team === p2.team;
    }

    function updateHostLogic(dt) {
        const gameDt = dt * activeSettings.gameSpeed; // APPLY GAME SPEED

        getLobbyRef().doc(lobbyId).collection('requests').get().then(snap => {
            snap.forEach(doc => { processAction(doc.data()); doc.ref.delete(); });
        });

        simState.players.forEach(p => {
            if (p.hp <= 0) { p.spawnQueue = []; return; }
            if (p.isBot) runBotLogic(p, gameDt);
            
            if (p.specialCooldown > 0) p.specialCooldown -= gameDt;

            if (p.spawnQueue.length > 0) {
                p.spawnTimer -= gameDt;
                if (p.spawnTimer <= 0 && p.spawnQueue.length > 0) {
                     const item = p.spawnQueue.shift();
                     spawnUnitReal(p.id, item.unitId);
                     if (p.spawnQueue.length > 0) {
                        const nextItem = p.spawnQueue[0];
                        const stats = getUnitStats(p.age, nextItem.unitId);
                        p.spawnTimer = stats ? stats.delay : 1.0;
                     } else { p.spawnTimer = 0; }
                }
            }
        });

        simState.units = simState.units.filter(u => u.hp > 0);
        simState.units.forEach(u => updateUnit(u, gameDt));

        simState.players.forEach(p => { if (p.hp > 0) updateTurrets(p, gameDt); });

        simState.projectiles = simState.projectiles.filter(p => {
            p.x += p.vx * gameDt * 400; p.y += p.vy * gameDt * 400;
            let hit = false;
            
            // Check Units
            // Team Logic: Don't hit friendly units (AOE might be exception, but simple here)
            const targets = simState.units.filter(u => u.ownerId !== p.ownerId && !isTeammate(u.ownerId, p.ownerId));
            for (let t of targets) {
                if (dist(p.x, p.y, t.x, t.y) < GAME_DATA.unitCollisionRadius + 5) {
                    t.hp -= p.damage;
                    hit = true;
                    simState.effects.push({x: t.x, y: t.y, type: 'hit', timer: 0.5});
                    if (t.hp <= 0) awardKill(p.ownerId, t);
                    break;
                }
            }
            
            // Check Bases
            if (!hit) {
                simState.players.forEach(pl => {
                    if (pl.id !== p.ownerId && !isTeammate(pl.id, p.ownerId) && pl.hp > 0 && dist(p.x, p.y, pl.x, pl.y) < GAME_DATA.baseRadius) {
                        pl.hp -= p.damage;
                        hit = true;
                        if (pl.hp <= 0) pl.hp = 0; 
                    }
                });
            }
            return !hit && Math.abs(p.x) < 2000 && Math.abs(p.y) < 2000; 
        });

        simState.effects = simState.effects.filter(e => { e.timer -= gameDt; return e.timer > 0; });
        
        // WIN CONDITION
        const alivePlayers = simState.players.filter(p => p.hp > 0);
        
        if (activeSettings.mode === 'TEAMS') {
            const t1Alive = alivePlayers.some(p => p.team === 1);
            const t2Alive = alivePlayers.some(p => p.team === 2);
            
            if (!t1Alive && t2Alive) endGame({ winnerTeam: 2 });
            else if (t1Alive && !t2Alive) endGame({ winnerTeam: 1 });
            else if (!t1Alive && !t2Alive) endGame({ winnerTeam: 0 }); // Draw
        } else {
            // FFA
            if (alivePlayers.length === 1 && simState.players.length > 1) {
                endGame({ winner: { id: alivePlayers[0].id, name: alivePlayers[0].name } });
            }
        }
    }
    
    function endGame(result) {
        gameState = 'finished';
        getLobbyRef().doc(lobbyId).update({ status: 'finished', ...result });
    }

    function hostSyncState() {
        if(gameState === 'finished') return;
        const stateJSON = JSON.stringify({
            units: simState.units.map(u => ({
                id: u.id, ownerId: u.ownerId, typeId: u.typeId, 
                x: Math.round(u.x), y: Math.round(u.y), 
                hp: u.hp, maxHp: u.maxHp, icon: u.icon
            })),
            projectiles: simState.projectiles,
            effects: simState.effects
        });
        getLobbyRef().doc(lobbyId).update({ stateJSON: stateJSON, lastHeartbeat: firebase.firestore.FieldValue.serverTimestamp() });
    }

    function hostSync() {
        if(gameState === 'finished') return;
        getLobbyRef().doc(lobbyId).update({ players: simState.players });
    }

    // --- Simulation Helpers ---

    function getUnitStats(ageIdx, unitId) {
        for (const age of GAME_DATA.ages) {
            const u = age.units.find(x => x.id === unitId);
            if (u) return u;
        }
        return null;
    }

    function runBotLogic(bot, dt) {
        // Only target enemies
        if (!bot.targetId || Math.random() < 0.01) {
            const enemies = simState.players.filter(p => p.id !== bot.id && !isTeammate(p.id, bot.id) && p.hp > 0);
            if (enemies.length > 0) {
                bot.targetId = enemies[Math.floor(Math.random() * enemies.length)].id;
            }
        }
        
        const nextAge = GAME_DATA.ages[bot.age + 1];
        const req = nextAge ? nextAge.xpReq * activeSettings.xpReq : Infinity;
        
        if (nextAge && bot.xp >= req) {
             bot.age++;
             bot.hp = Math.min(bot.hp + 500, activeSettings.baseHp);
             bot.maxHp = activeSettings.baseHp;
             bot.turrets = [{ id: 'base_turret', typeId: GAME_DATA.ages[bot.age].turret.id, cooldown: 0, slot: 0 }];
        }
        const ageData = GAME_DATA.ages[bot.age];
        if (bot.spawnQueue.length < 3 && Math.random() < 0.02) { 
            const unitOpts = ageData.units;
            const pick = unitOpts[Math.floor(Math.random() * unitOpts.length)];
            const realCost = pick.cost * activeSettings.unitCost;
            if (bot.gold >= realCost) {
                bot.gold -= realCost;
                bot.spawnQueue.push({ reqId: 'bot_'+Math.random(), unitId: pick.id });
                if (bot.spawnQueue.length === 1) bot.spawnTimer = pick.delay;
            }
        }
        if (bot.specialCooldown <= 0 && ageData.special && bot.targetId) {
             const t = simState.players.find(p => p.id === bot.targetId);
             if (t) useSpecial(bot.id, t.x, t.y);
        }
    }

    function updateUnit(u, dt) {
        const owner = simState.players.find(p => p.id === u.ownerId);
        const targetPlayer = simState.players.find(p => p.id === u.targetId);
        const unitRadius = GAME_DATA.unitCollisionRadius;
        
        if(u.cooldownTimer > 0) u.cooldownTimer -= dt * 60;

        // Validation: If target is teammate or dead, switch target
        if (!targetPlayer || targetPlayer.hp <= 0 || isTeammate(u.ownerId, targetPlayer.id)) {
            let close = null, minDist = Infinity;
            simState.players.forEach(p => {
                if (p.id !== u.ownerId && !isTeammate(p.id, u.ownerId) && p.hp > 0) {
                    const d = dist(u.x, u.y, p.x, p.y);
                    if (d < minDist) { minDist = d; close = p; }
                }
            });
            if (close) u.targetId = close.id; 
            return;
        }

        let enemy = null, enemyDist = Infinity;
        
        for (let other of simState.units) {
            // Aggression: Only attack enemies
            if (other.ownerId !== u.ownerId && !isTeammate(other.ownerId, u.ownerId)) {
                const d = dist(u.x, u.y, other.x, other.y);
                const combinedRadii = unitRadius * 2;
                const maxRange = Math.max(u.meleeRange, u.rangedRange);
                
                if (d <= maxRange + combinedRadii && d < enemyDist) {
                    enemyDist = d;
                    enemy = other;
                }
            }
        }
        
        if (!enemy) {
             const d = dist(u.x, u.y, targetPlayer.x, targetPlayer.y);
             const baseRadius = GAME_DATA.baseRadius;
             const maxRange = Math.max(u.meleeRange, u.rangedRange);
             
             if (d <= maxRange + unitRadius + baseRadius) {
                 enemy = { type: 'base', x: targetPlayer.x, y: targetPlayer.y, id: targetPlayer.id, radius: baseRadius };
                 enemyDist = d;
             }
        }

        if (enemy) {
            const enemyRadius = enemy.type === 'base' ? GAME_DATA.baseRadius : unitRadius;
            const isMeleeRange = enemyDist <= u.meleeRange + unitRadius + enemyRadius;
            const isRangedRange = u.rangedDmg > 0 && enemyDist <= u.rangedRange + unitRadius + enemyRadius;

            if (u.cooldownTimer <= 0) {
                if (isMeleeRange && u.meleeDmg > 0) {
                    if (enemy.type === 'base') {
                        const p = simState.players.find(pl => pl.id === enemy.id);
                        if(p) p.hp -= u.meleeDmg;
                    } else {
                        enemy.hp -= u.meleeDmg;
                        if(enemy.hp <= 0) awardKill(u.ownerId, enemy);
                    }
                    simState.effects.push({x: enemy.x, y: enemy.y, type: 'hit', timer: 0.2});
                    u.cooldownTimer = 60; 
                } else if (isRangedRange) {
                    simState.projectiles.push({
                        x: u.x, y: u.y, 
                        vx: (enemy.x - u.x) / dist(u.x, u.y, enemy.x, enemy.y),
                        vy: (enemy.y - u.y) / dist(u.x, u.y, enemy.x, enemy.y),
                        damage: u.rangedDmg,
                        ownerId: u.ownerId
                    });
                    u.cooldownTimer = 60;
                } else {
                    moveUnit(u, targetPlayer, dt);
                }
            }
        } else {
            moveUnit(u, targetPlayer, dt);
        }
    }

    function moveUnit(u, targetPlayer, dt) {
        let canMove = true;
        const step = activeSettings.gameSpeed * dt * 50; 
        const angle = Math.atan2(targetPlayer.y - u.y, targetPlayer.x - u.x);
        const nextX = u.x + Math.cos(angle) * step;
        const nextY = u.y + Math.sin(angle) * step;

        for (let other of simState.units) {
            if (other.id !== u.id) {
                const d = dist(nextX, nextY, other.x, other.y);
                if (d < GAME_DATA.unitCollisionRadius * 2) {
                    const dx = other.x - u.x;
                    const dy = other.y - u.y;
                    const dot = dx * Math.cos(angle) + dy * Math.sin(angle);
                    if (dot > 0) { canMove = false; break; }
                }
            }
        }

        if (canMove) { u.x = nextX; u.y = nextY; }
    }

    function updateTurrets(p, dt) {
        p.turrets.forEach(t => {
            const tData = getTurretData(t.typeId);
            if (!tData) return;
            
            if (t.cooldown > 0) t.cooldown -= dt * 60;
            
            if (t.cooldown <= 0) {
                let target = null;
                let minD = tData.range;
                for (let u of simState.units) {
                    // Only target enemies
                    if (u.ownerId !== p.id && !isTeammate(u.ownerId, p.id)) {
                        const d = dist(p.x, p.y, u.x, u.y);
                        if (d < minD) { minD = d; target = u; }
                    }
                }
                
                if (target) {
                    simState.projectiles.push({
                        x: p.x, y: p.y,
                        vx: (target.x - p.x) / dist(p.x, p.y, target.x, target.y),
                        vy: (target.y - p.y) / dist(p.x, p.y, target.x, target.y),
                        damage: tData.damage,
                        ownerId: p.id
                    });
                    t.cooldown = tData.cooldown;
                }
            }
        });
    }

    function spawnUnitReal(playerId, unitId) {
        const p = simState.players.find(x => x.id === playerId);
        const stats = getUnitStats(p.age, unitId);
        
        let spawnX = p.x, spawnY = p.y;
        
        // Spawn towards target (if valid enemy)
        if (p.targetId && !isTeammate(p.id, p.targetId)) {
            const target = simState.players.find(tp => tp.id === p.targetId);
            if (target) {
                const a = Math.atan2(target.y - p.y, target.x - p.x);
                spawnX += Math.cos(a) * (GAME_DATA.baseRadius + 20);
                spawnY += Math.sin(a) * (GAME_DATA.baseRadius + 20);
            }
        } else {
             const a = Math.atan2(-p.y, -p.x);
             spawnX += Math.cos(a) * (GAME_DATA.baseRadius + 20);
             spawnY += Math.sin(a) * (GAME_DATA.baseRadius + 20);
        }

        simState.units.push({
            id: Math.random().toString(36),
            ownerId: p.id,
            typeId: unitId,
            x: spawnX,
            y: spawnY,
            hp: stats.hp,
            maxHp: stats.hp,
            meleeDmg: stats.meleeDmg,
            rangedDmg: stats.rangedDmg,
            meleeRange: stats.meleeRange,
            rangedRange: stats.rangedRange,
            cooldownTimer: 0,
            targetId: p.targetId,
            icon: stats.icon,
            cost: stats.cost * activeSettings.unitCost
        });
    }

    function useSpecial(playerId, x, y) {
        const p = simState.players.find(x => x.id === playerId);
        const age = GAME_DATA.ages[p.age];
        if(!age.special) return;
        if (p.specialCooldown > 0) return;

        p.specialCooldown = age.special.cooldown;
        simState.effects.push({x, y, type: 'explosion', radius: age.special.radius, timer: 1.0});
        
        simState.units.forEach(u => {
            // Friendly Fire Protection for special (optional, but good for teams)
            if (u.ownerId !== playerId && !isTeammate(u.ownerId, playerId) && dist(u.x, u.y, x, y) < age.special.radius) {
                u.hp -= age.special.damage;
                if(u.hp <= 0) awardKill(playerId, u);
            }
        });
    }

    function awardKill(killerId, victimUnit) {
        const killer = simState.players.find(p => p.id === killerId);
        if (killer && victimUnit.cost) {
            // Apply Multipliers
            const baseCost = victimUnit.cost / activeSettings.unitCost; // revert to base to calculate reward
            killer.gold += Math.ceil((baseCost * 1.3) * activeSettings.goldMult);
            killer.xp += Math.floor((baseCost * 1.0) * activeSettings.xpMult);
        }
    }

    function processAction(action) {
        if (action.type === 'queueUnit') {
            const p = simState.players.find(x => x.id === action.playerId);
            if (p && p.hp > 0) {
                 const stats = getUnitStats(p.age, action.unitId);
                 const cost = stats.cost * activeSettings.unitCost;
                 if (stats && p.gold >= cost) {
                     p.gold -= cost;
                     p.spawnQueue.push({ unitId: action.unitId, reqId: action.reqId });
                     if (p.spawnQueue.length === 1) p.spawnTimer = stats.delay;
                 }
            }
        } else if (action.type === 'setTarget') {
            const p = simState.players.find(x => x.id === action.playerId);
            if (p) {
                // Prevent targeting teammate
                if (!isTeammate(p.id, action.targetId)) {
                    p.targetId = action.targetId;
                }
            }
        } else if (action.type === 'upgrade') {
            const p = simState.players.find(x => x.id === action.playerId);
            if (p) {
                const nextAge = GAME_DATA.ages[p.age + 1];
                const req = nextAge ? nextAge.xpReq * activeSettings.xpReq : Infinity;
                if (nextAge && p.xp >= req) {
                    p.age++;
                    p.hp += 500;
                    p.maxHp = activeSettings.baseHp;
                    p.turrets = [{ id: 'base_turret', typeId: GAME_DATA.ages[p.age].turret.id, cooldown: 0, slot: 0 }];
                }
            }
        } else if (action.type === 'special') {
             useSpecial(action.playerId, action.x, action.y);
        }
    }

    // --- Client Interaction ---
    
    let lastClientTime = performance.now();
    
    function clientRenderLoop(time) {
        const dt = (time - lastClientTime) / 1000;
        lastClientTime = time;
        
        if (pendingQueue.length > 0) pendingQueue = pendingQueue.filter(p => Date.now() - p.timestamp < 5000);
        simState.players.forEach(p => { if (p._visualTimer > 0) p._visualTimer = Math.max(0, p._visualTimer - dt); });

        renderGame(dt);
        updateUI();
        if (gameState !== 'finished') requestAnimationFrame(clientRenderLoop);
    }

    function sendAction(data) {
        const now = Date.now();
        const reqId = localPlayerId + '_' + now + '_' + Math.random();

        if (data.type === 'queueUnit') {
            lastUnitBuyTime = now;
            if (!isHost) {
                const p = simState.players.find(x => x.id === localPlayerId);
                const stats = getUnitStats(p.age, data.unitId);
                const cost = stats.cost * activeSettings.unitCost;
                if (p && stats && p.gold >= cost) {
                    pendingQueue.push({ unitId: data.unitId, reqId: reqId, timestamp: now, cost: cost, startTime: now });
                    updateUI();
                }
            }
        }

        const payload = { ...data, playerId: localPlayerId, reqId: reqId };
        if (isHost) processAction(payload);
        else getLobbyRef().doc(lobbyId).collection('requests').add({ ...payload, timestamp: firebase.firestore.FieldValue.serverTimestamp() });
    }

    function handleInput() {
        const rect = canvas.getBoundingClientRect();
        const mx = (input.mouse.x - rect.left - canvas.width/2) / camera.zoom + camera.x;
        const my = (input.mouse.y - rect.top - canvas.height/2) / camera.zoom + camera.y;

        if (input.mode === 'ability') {
            sendAction({ type: 'special', x: mx, y: my });
            input.mode = 'select';
            document.body.style.cursor = 'default';
            return;
        }

        let clickedBase = null;
        simState.players.forEach(p => { if (dist(mx, my, p.x, p.y) < GAME_DATA.baseRadius) clickedBase = p; });

        if (clickedBase && clickedBase.id !== localPlayerId) {
            // Client side protection for feedback
            if (activeSettings.mode === 'TEAMS' && isTeammate(localPlayerId, clickedBase.id)) {
                // Do nothing or show "Friendly"
                const ts = document.getElementById('target-status');
                ts.innerText = "Cannot Attack Teammate!";
                ts.className = "glass-panel px-6 py-3 rounded font-bold text-xl text-yellow-500";
                setTimeout(updateUI, 1000);
            } else {
                sendAction({ type: 'setTarget', targetId: clickedBase.id });
            }
        }
    }

    // --- Rendering ---

    function renderGame(dt) {
        if (!dt || dt > 0.5) dt = 0.016;

        ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x, -camera.y);

        ctx.strokeStyle = '#333'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(0, 0, GAME_DATA.mapRadius, 0, Math.PI * 2); ctx.stroke();

        simState.players.forEach(p => {
            if (p.hp <= 0) { ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(p.x, p.y, GAME_DATA.baseRadius, 0, Math.PI*2); ctx.fill(); return; }
            
            const me = simState.players.find(me => me.id === localPlayerId);
            if (me && me.targetId === p.id) {
                ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(p.x, p.y, GAME_DATA.baseRadius + 10, 0, Math.PI*2); ctx.stroke();
            }
            // Team Ring
            if (activeSettings.mode === 'TEAMS') {
                 ctx.strokeStyle = p.color; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(p.x, p.y, GAME_DATA.baseRadius + 4, 0, Math.PI*2); ctx.stroke();
            }

            ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, GAME_DATA.baseRadius, 0, Math.PI*2); ctx.fill();
            
            if(p.turrets.length > 0) {
                const tur = p.turrets[0]; const tData = getTurretData(tur.typeId);
                ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(p.x, p.y, 30, 0, Math.PI*2); ctx.fill(); 
                ctx.fillStyle = '#fff'; ctx.font = '36px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(tData.icon, p.x, p.y);
            }

            drawBar(p.x, p.y - GAME_DATA.baseRadius - 15, 120, 12, p.hp, p.maxHp, '#0f0');
            ctx.fillStyle = '#fff'; ctx.font = '22px Arial'; ctx.fillText(p.name, p.x, p.y - GAME_DATA.baseRadius - 40);
        });

        const unitsToDraw = isHost ? simState.units : Array.from(renderState.units.values());
        unitsToDraw.forEach(u => {
            if (!isHost) {
                const t = 1.0 - Math.pow(0.001, dt); 
                u.x += (u.targetX - u.x) * t; u.y += (u.targetY - u.y) * t;
                if (dist(u.x, u.y, u.targetX, u.targetY) > 60) { u.x = u.targetX; u.y = u.targetY; }
            }
            const p = simState.players.find(pl => pl.id === u.ownerId);
            const color = p ? p.color : '#fff';
            
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(u.x, u.y, 28, 0, Math.PI*2); ctx.fill();
            ctx.font = '44px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(u.icon, u.x, u.y);
            drawBar(u.x, u.y - 48, 48, 8, u.hp, u.maxHp, '#0f0');
        });

        simState.projectiles.forEach(p => {
            if (!isHost) { p.x += p.vx * dt * 400; p.y += p.vy * dt * 400; }
            ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI*2); ctx.fill();
        });
        
        simState.effects.forEach(e => {
            if (e.type === 'hit') { ctx.fillStyle = `rgba(255, 255, 255, ${e.timer * 2})`; ctx.beginPath(); ctx.arc(e.x, e.y, 20, 0, Math.PI*2); ctx.fill(); }
            else if (e.type === 'explosion') { ctx.fillStyle = `rgba(255, 100, 0, ${e.timer})`; ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill(); }
        });

        if (input.mode === 'ability') {
            const me = simState.players.find(x => x.id === localPlayerId);
            const age = GAME_DATA.ages[me.age];
            if(age && age.special) {
                const wx = (input.mouse.x - canvas.width/2) / camera.zoom + camera.x;
                const wy = (input.mouse.y - canvas.height/2) / camera.zoom + camera.y;
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(wx, wy, age.special.radius, 0, Math.PI*2); ctx.stroke(); ctx.fill();
            }
        }
        ctx.restore();
    }

    function drawBar(x, y, w, h, val, max, color) {
        ctx.fillStyle = '#000'; ctx.fillRect(x - w/2, y, w, h);
        ctx.fillStyle = color; const fill = Math.max(0, (val / max) * w); ctx.fillRect(x - w/2, y, fill, h);
    }

    // --- UI Updates ---
    
    let currentRenderedAge = -1;

    function updateUI() {
        const p = simState.players.find(x => x.id === localPlayerId);
        if (!p) return;

        const ageIndex = p.age;
        const ageData = GAME_DATA.ages[ageIndex];
        const nextAge = GAME_DATA.ages[ageIndex + 1];

        let displayGold = p.gold;
        if (!isHost) pendingQueue.forEach(req => { displayGold -= req.cost; });
        
        document.getElementById('stats-gold').innerText = Math.floor(Math.max(0, displayGold));
        document.getElementById('stats-xp').innerText = Math.floor(p.xp);
        
        // Queue UI
        const queueDiv = document.getElementById('queue-bar');
        let displayQueue = p.spawnQueue ? [...p.spawnQueue] : [];
        const mappedPending = pendingQueue.map(pq => ({ unitId: pq.unitId, isPending: true, startTime: pq.startTime }));
        displayQueue = displayQueue.concat(mappedPending);

        if (displayQueue.length > 0) {
            queueDiv.classList.remove('hidden');
            queueDiv.innerHTML = displayQueue.map((item, idx) => {
                const uStats = getUnitStats(p.age, item.unitId);
                if (!uStats) return '';
                let pct = 0;
                if (idx === 0) {
                    if (item.isPending) { const elapsed = (Date.now() - item.startTime) / 1000; pct = Math.min(100, Math.max(0, (elapsed / uStats.delay) * 100)); }
                    else if (isHost) { pct = Math.min(100, Math.max(0, (1 - (p.spawnTimer / uStats.delay)) * 100)); }
                    else { pct = Math.min(100, Math.max(0, (1 - (p._visualTimer / uStats.delay)) * 100)); }
                }
                const opacity = item.isPending ? 'opacity-70' : '';
                return `<div class="queue-item ${opacity}">${uStats.icon}${idx === 0 ? `<div class="queue-progress" style="width: ${pct}%"></div>` : ''}</div>`;
            }).join('');
        } else {
            queueDiv.classList.add('hidden'); queueDiv.innerHTML = '';
        }

        // Unit Bar
        const unitContainer = document.getElementById('unit-bar');
        if (currentRenderedAge !== ageIndex) {
            currentRenderedAge = ageIndex;
            unitContainer.innerHTML = ageData.units.map(u => `
                <div id="btn-unit-${u.id}" class="unit-card relative w-24 h-24 rounded cursor-pointer flex flex-col items-center justify-center" 
                     onclick="sendAction({type: 'queueUnit', unitId: '${u.id}'})">
                    <span class="text-5xl pointer-events-none">${u.icon}</span> 
                    <span class="text-base text-yellow-400 font-bold pointer-events-none" id="cost-display-${u.id}">$${u.cost}</span>
                    <div class="tooltip pointer-events-none">
                        <b class="text-yellow-400 text-xl">${u.name}</b><br/>
                        <div class="grid grid-cols-2 gap-2 mt-1">
                            <span>â¤ï¸ HP: ${u.hp}</span>
                            <span>â±ï¸ Train: ${u.delay}s</span>
                            <span>âš”ï¸ Melee: ${u.meleeDmg}</span>
                            <span>ðŸ¹ Range: ${u.rangedDmg}</span>
                        </div>
                    </div>
                </div>
            `).join('');

            const specialBtn = document.getElementById('special-btn');
            if (ageData.special) {
                specialBtn.innerHTML = `<span class="pointer-events-none text-4xl">â­</span><span class="text-sm pointer-events-none">${ageData.special.name}</span><div id="special-cd-overlay" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center text-white font-bold hidden text-2xl"></div>`;
                specialBtn.onclick = () => { input.mode = 'ability'; document.body.style.cursor = 'crosshair'; };
                specialBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-800'); specialBtn.classList.add('bg-purple-900', 'border-purple-500', 'hover:bg-purple-800');
            } else {
                specialBtn.innerHTML = 'Locked'; specialBtn.onclick = null;
                specialBtn.classList.add('opacity-50', 'cursor-not-allowed', 'bg-gray-800'); specialBtn.classList.remove('bg-purple-900', 'border-purple-500', 'hover:bg-purple-800');
            }
        }

        // Dynamic cost updates
        ageData.units.forEach(u => {
            const btn = document.getElementById(`btn-unit-${u.id}`);
            const realCost = u.cost * activeSettings.unitCost;
            document.getElementById(`cost-display-${u.id}`).innerText = '$' + Math.ceil(realCost);
            if (btn) {
                if (displayGold < realCost) btn.classList.add('disabled');
                else btn.classList.remove('disabled');
            }
        });

        const cdOverlay = document.getElementById('special-cd-overlay');
        const specialBtn = document.getElementById('special-btn');
        if (p.specialCooldown > 0 && cdOverlay) {
             cdOverlay.classList.remove('hidden'); cdOverlay.innerText = Math.ceil(p.specialCooldown);
             specialBtn.onclick = null; specialBtn.classList.add('cursor-not-allowed');
        } else if (cdOverlay) {
             cdOverlay.classList.add('hidden');
             specialBtn.onclick = () => { input.mode = 'ability'; document.body.style.cursor = 'crosshair'; };
             specialBtn.classList.remove('cursor-not-allowed');
        }

        const upgradeBtn = document.getElementById('upgrade-btn');
        if (nextAge) {
            upgradeBtn.classList.remove('hidden');
            const req = nextAge.xpReq * activeSettings.xpReq;
            const canAfford = p.xp >= req;
            
            if (canAfford) {
                upgradeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                upgradeBtn.onclick = () => { sendAction({type: 'upgrade'}); };
            } else {
                upgradeBtn.classList.add('opacity-50', 'cursor-not-allowed');
                upgradeBtn.onclick = null;
            }
            upgradeBtn.innerHTML = `Evolve to ${nextAge.name}<br/><span class="text-xs">${req} XP</span>`;
        } else {
            upgradeBtn.classList.add('hidden');
        }
        
        const targetStatus = document.getElementById('target-status');
        if (p.targetId) {
            const t = simState.players.find(x => x.id === p.targetId);
            targetStatus.innerText = `Target: ${t ? t.name : 'Unknown'}`;
            targetStatus.className = "glass-panel px-6 py-3 rounded font-bold text-xl text-white";
        } else {
            targetStatus.innerText = "Select Target";
            targetStatus.className = "glass-panel px-6 py-3 rounded font-bold text-xl text-red-400 animate-pulse";
        }
    }

    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    function dist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)**2 + (y2-y1)**2); }
    function getTurretData(tid) { for(let a of GAME_DATA.ages) { if (a.turret && a.turret.id === tid) return a.turret; } return null; }

    window.addEventListener('DOMContentLoaded', () => { initApp(); });
</script>

<!-- === UI LAYOUT === -->
<div id="lobby-screen" class="screen w-full h-full flex flex-col md:flex-row items-center justify-center relative bg-gray-900 gap-8 p-4">
    <div class="absolute bottom-4 right-4 text-gray-600 text-sm">Build: <span id="version-display"></span></div>

    <!-- MAIN MENU PANEL -->
    <div class="glass-panel p-8 rounded-xl max-w-md w-full text-center">
        <h1 class="text-5xl font-bold mb-6 text-yellow-500">Age of War</h1>
        <div id="auth-status" class="mb-6 text-base text-yellow-500 animate-pulse">Connecting...</div>

        <div class="flex flex-col gap-4">
            <input id="lobby-name" type="text" placeholder="Your Name" class="bg-gray-800 border border-gray-600 p-4 rounded text-white text-xl">
            <div class="flex items-center gap-4 bg-gray-800 p-3 rounded border border-gray-600">
                <span class="text-lg text-gray-300">Base Color:</span>
                <input id="player-color" type="color" value="#ff0000" class="flex-1">
            </div>
            <div class="flex items-center gap-2 justify-center text-gray-400 mb-2">
                 <input type="checkbox" id="is-private-lobby">
                 <label for="is-private-lobby">Private Game (Code Only)</label>
            </div>
            <button onclick="createLobby()" class="btn-primary w-full py-4 text-xl">Create New Game</button>
            <div class="flex gap-2 mt-4">
                <input id="lobby-id-input" type="text" placeholder="CODE" class="bg-gray-800 border border-gray-600 p-3 rounded flex-1 text-white text-base text-center uppercase tracking-widest">
                <button onclick="joinLobby()" class="bg-blue-600 hover:bg-blue-500 text-white px-6 rounded font-bold text-lg">Join</button>
            </div>
        </div>
    </div>
    
    <!-- PUBLIC BROWSER PANEL -->
    <div class="glass-panel p-6 rounded-xl w-80 h-96 flex flex-col">
        <h2 class="text-xl font-bold text-gray-300 mb-4 border-b border-gray-600 pb-2">Public Games</h2>
        <div id="active-lobbies-list" class="flex-1 overflow-y-auto pr-2">
            <div class="text-gray-500 text-sm text-center mt-10">Loading...</div>
        </div>
    </div>
</div>

<div id="waiting-room" class="screen hidden w-full h-full flex flex-col items-center justify-center bg-gray-900 p-6 overflow-hidden">
    <div class="flex flex-col md:flex-row gap-6 w-full max-w-6xl h-full max-h-[800px]">
        
        <!-- LEFT: Player List -->
        <div class="glass-panel p-6 rounded-xl flex-1 flex flex-col min-w-[300px]">
            <h2 class="text-3xl font-bold mb-2">Lobby</h2>
            <div id="copy-box" class="bg-black p-3 rounded mb-4 text-sm font-mono text-gray-400 cursor-pointer transition flex justify-between items-center" onclick="copyLobbyId()">
                <span>Code: <span id="display-lobby-id" class="text-white font-bold select-all text-lg tracking-widest"></span></span>
                <span class="text-xs bg-gray-700 px-2 py-1 rounded">COPY</span>
            </div>
            <div class="mb-4 flex-1 overflow-hidden flex flex-col">
                <h3 class="text-lg text-gray-400 mb-2">Players</h3>
                <div id="player-list" class="flex-1 overflow-y-auto pr-2 text-base"></div>
            </div>
            <div class="flex gap-2 mb-2">
                <button id="add-bot-btn" onclick="addBot()" class="bg-gray-600 hover:bg-gray-500 text-white px-4 py-3 rounded flex-1">Add Bot</button>
                <button id="start-btn" onclick="setGameStarted()" class="btn-primary flex-1 text-xl">Start Game</button>
            </div>
            <button onclick="leaveLobby()" class="text-red-500 hover:text-red-400 text-sm underline text-center mt-2">Leave Lobby</button>
        </div>

        <!-- RIGHT: Settings -->
        <div id="settings-panel" class="glass-panel p-6 rounded-xl flex-1 flex flex-col min-w-[300px] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-200">Game Settings</h2>
                <button id="reset-btn" onclick="resetSettings()" class="text-xs text-yellow-500 hover:text-yellow-400 underline">Reset Defaults</button>
            </div>

            <!-- Mode Selector -->
            <div class="mb-6">
                <label class="block text-gray-400 text-sm mb-1">Game Mode</label>
                <select id="set-mode" onchange="updateLobbySettings()" class="w-full bg-gray-800 border border-gray-600 p-2 rounded text-white">
                    <option value="FFA">Free For All</option>
                    <option value="TEAMS">Team vs Team (2 Teams)</option>
                </select>
                <p class="text-xs text-gray-500 mt-1">Teams share victory. No friendly fire.</p>
            </div>
            
            <div class="team-only hidden mb-6">
                 <label class="block text-gray-400 text-sm mb-1">Map Layout</label>
                 <select id="set-layout" onchange="updateLobbySettings()" class="w-full bg-gray-800 border border-gray-600 p-2 rounded text-white">
                     <option value="alternating">Checkerboard (T1, T2, T1...)</option>
                     <option value="together">Together (T1s vs T2s)</option>
                 </select>
            </div>

            <!-- Sliders -->
            <div class="space-y-4">
                <div>
                    <div class="flex justify-between text-sm mb-1"><span>Game Speed</span><span id="val-speed" class="text-yellow-400">1.0x</span></div>
                    <input id="set-speed" type="range" min="0.5" max="3.0" step="0.1" value="1.0" oninput="updateLobbySettings()">
                </div>
                <div>
                    <div class="flex justify-between text-sm mb-1"><span>Unit Cost</span><span id="val-cost" class="text-yellow-400">1.0x</span></div>
                    <input id="set-cost" type="range" min="0.1" max="5.0" step="0.1" value="1.0" oninput="updateLobbySettings()">
                </div>
                <div>
                    <div class="flex justify-between text-sm mb-1"><span>Gold Reward</span><span id="val-gold" class="text-yellow-400">1.0x</span></div>
                    <input id="set-gold" type="range" min="0.5" max="5.0" step="0.1" value="1.0" oninput="updateLobbySettings()">
                </div>
                <div>
                    <div class="flex justify-between text-sm mb-1"><span>XP Reward</span><span id="val-xp" class="text-yellow-400">1.0x</span></div>
                    <input id="set-xp" type="range" min="0.5" max="5.0" step="0.1" value="1.0" oninput="updateLobbySettings()">
                </div>
                <div>
                    <div class="flex justify-between text-sm mb-1"><span>XP to Level Up</span><span id="val-xpreq" class="text-yellow-400">1.0x</span></div>
                    <input id="set-xpreq" type="range" min="0.1" max="2.0" step="0.1" value="1.0" oninput="updateLobbySettings()">
                </div>
                <div>
                    <div class="flex justify-between text-sm mb-1"><span>Base HP</span><span id="val-hp" class="text-yellow-400">2500</span></div>
                    <input id="set-hp" type="range" min="500" max="10000" step="500" value="2500" oninput="updateLobbySettings()">
                </div>
            </div>
        </div>
    </div>
</div>

<div id="game-screen" class="screen hidden w-full h-full">
    <canvas id="game-canvas"></canvas>
    <div id="connection-overlay" class="absolute inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center hidden">
        <div class="glass-panel p-8 rounded-xl text-center"><h2 class="text-3xl font-bold text-red-500 mb-2">Connection Lost</h2><p class="text-gray-300">Waiting for Host...</p></div>
    </div>
    <div class="game-ui flex flex-col justify-between p-6">
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="glass-panel p-4 rounded flex gap-6 text-base">
                <div class="flex flex-col"><span class="text-yellow-400 font-bold text-lg">GOLD</span><span id="stats-gold" class="text-3xl">0</span></div>
                <div class="flex flex-col border-l border-gray-600 pl-6"><span class="text-blue-400 font-bold text-lg">XP</span><span id="stats-xp" class="text-3xl">0</span></div>
            </div>
            <div id="target-status" class="glass-panel px-6 py-3 rounded font-bold text-red-400 animate-pulse text-xl">Select Target</div>
            <div class="glass-panel p-3 rounded"><button id="upgrade-btn" class="btn-primary text-lg hidden p-4">Evolve</button></div>
        </div>
        <div class="flex flex-col items-center gap-4 pointer-events-auto pb-6">
            <div id="queue-bar" class="flex gap-2 mb-2 hidden"></div>
            <div class="flex items-end gap-6">
                <button id="special-btn" class="relative w-24 h-24 rounded bg-purple-900 border-2 border-purple-500 hover:bg-purple-800 flex flex-col items-center justify-center transition overflow-hidden">Locked</button>
                <div id="unit-bar" class="flex gap-4 glass-panel p-4 rounded-xl"></div>
            </div>
        </div>
    </div>
</div>

</body>
</html>